var OV = (() => {
    var Fi = Object.defineProperty;
    var Un = Object.getOwnPropertyDescriptor;
    var zn = Object.getOwnPropertyNames;
    var _n = Object.prototype.hasOwnProperty;
    var Hn = (s, e) => {
            for (var t in e) Fi(s, t, { get: e[t], enumerable: !0 });
        },
        kn = (s, e, t, r) => {
            if ((e && typeof e == "object") || typeof e == "function")
                for (let i of zn(e))
                    !_n.call(s, i) &&
                        i !== t &&
                        Fi(s, i, {
                            get: () => e[i],
                            enumerable: !(r = Un(e, i)) || r.enumerable,
                        });
            return s;
        };
    var jn = (s) => kn(Fi({}, "__esModule", { value: !0 }), s);
    var Xn = {};
    Hn(Xn, {
        AddCoord2D: () => hn,
        AddCoord3D: () => Jr,
        AddDiv: () => Sn,
        AddDomElement: () => Xi,
        ArrayBufferToAsciiString: () => nn,
        ArrayBufferToUtf8String: () => K,
        ArrayToColor: () => ri,
        ArrayToCoord3D: () => Re,
        ArrayToQuaternion: () => $e,
        AsciiStringToArrayBuffer: () => on,
        Base64DataURIToArrayBuffer: () => at,
        BezierTweenFunction: () => Mn,
        BigEps: () => en,
        BinaryReader: () => de,
        BinaryWriter: () => Pe,
        BoundingBoxCalculator3D: () => Nt,
        Box3D: () => mt,
        CalculateSurfaceArea: () => En,
        CalculateTriangleNormal: () => ht,
        CalculateVolume: () => In,
        Camera: () => Ae,
        CameraIsEqual3D: () => vi,
        CheckModel: () => dn,
        ClearDomElement: () => wn,
        ClickDetector: () => _r,
        Color: () => R,
        ColorComponentFromFloat: () => he,
        ColorFromFloatComponents: () => be,
        ColorIsEqual: () => Ye,
        ColorToHexString: () => ze,
        ColorToMaterialConverter: () => Ot,
        ConvertColorToThreeColor: () => xe,
        ConvertMeshToMeshBuffer: () => ot,
        ConvertModelToThreeObject: () => Ii,
        ConvertThreeColorToColor: () => Ut,
        ConvertThreeGeometryToMesh: () => Je,
        Coord2D: () => F,
        Coord3D: () => y,
        Coord4D: () => Ee,
        CoordDistance2D: () => Er,
        CoordDistance3D: () => Ie,
        CoordIsEqual2D: () => Fe,
        CoordIsEqual3D: () => ye,
        CopyObjectAttributes: () => Rt,
        CreateDiv: () => Vn,
        CreateDomElement: () => wi,
        CreateModelUrlParameters: () => Ln,
        CreateObjectUrl: () => ut,
        CreateObjectUrlWithMimeType: () => Zr,
        CreateUrlBuilder: () => Zi,
        CreateUrlParser: () => On,
        CrossVector3D: () => Ge,
        DegRad: () => Ze,
        Direction: () => w,
        DotVector3D: () => Tr,
        EmbeddedViewer: () => qr,
        Eps: () => $i,
        ExportedFile: () => j,
        Exporter: () => yi,
        Exporter3dm: () => nr,
        ExporterBase: () => te,
        ExporterBim: () => or,
        ExporterGltf: () => ir,
        ExporterModel: () => sr,
        ExporterObj: () => lr,
        ExporterOff: () => ar,
        ExporterPly: () => ur,
        ExporterSettings: () => Or,
        ExporterStl: () => hr,
        FaceMaterial: () => Ft,
        File: () => pt,
        FileFormat: () => B,
        FileList: () => xt,
        FileSource: () => $,
        FinalizeModel: () => ii,
        FlipMeshTrianglesOrientation: () => ti,
        GenerateCone: () => Fr,
        GenerateCuboid: () => xi,
        GenerateCylinder: () => gi,
        GeneratePlatonicSolid: () => Ti,
        GenerateSphere: () => Ci,
        Generator: () => it,
        GeneratorHelper: () => Zt,
        GeneratorParams: () => Ct,
        GetBoundingBox: () => Pi,
        GetDefaultCamera: () => Gi,
        GetDomElementClientCoordinates: () => Ke,
        GetDomElementExternalHeight: () => bi,
        GetDomElementExternalWidth: () => Mi,
        GetDomElementInnerDimensions: () => Si,
        GetDomElementOuterHeight: () => Nn,
        GetDomElementOuterWidth: () => Fn,
        GetExternalLibPath: () => Gr,
        GetFileExtension: () => ke,
        GetFileExtensionFromMimeType: () => Qe,
        GetFileName: () => ee,
        GetIntegerFromStyle: () => re,
        GetMeshType: () => et,
        GetShadingType: () => mi,
        GetShadingTypeOfObject: () => Ki,
        GetTetrahedronSignedVolume: () => qi,
        GetTopology: () => Vi,
        GetTriangleArea: () => Wi,
        HasDefaultMaterial: () => cn,
        HasHighpDriverIssue: () => di,
        HexStringToColor: () => un,
        ImportError: () => nt,
        ImportErrorCode: () => We,
        ImportResult: () => Nr,
        ImportSettings: () => tr,
        Importer: () => rr,
        Importer3dm: () => zt,
        Importer3ds: () => Wt,
        ImporterBase: () => _,
        ImporterBim: () => er,
        ImporterFileAccessor: () => Dr,
        ImporterGltf: () => qt,
        ImporterIfc: () => Kt,
        ImporterO3dv: () => Qt,
        ImporterObj: () => Yt,
        ImporterOff: () => Lt,
        ImporterPly: () => Jt,
        ImporterStl: () => Xt,
        ImporterStp: () => $t,
        ImporterThree3mf: () => jt,
        ImporterThreeBase: () => je,
        ImporterThreeDae: () => Ht,
        ImporterThreeFbx: () => _t,
        ImporterThreeSvg: () => ci,
        ImporterThreeWrl: () => kt,
        Init3DViewerElement: () => Qi,
        Init3DViewerElements: () => Bn,
        InsertDomElementAfter: () => An,
        InsertDomElementBefore: () => vn,
        IntegerToHexString: () => Z,
        IsDefined: () => Gt,
        IsDomElementVisible: () => Rn,
        IsEqual: () => U,
        IsEqualEps: () => rn,
        IsGreater: () => Yr,
        IsGreaterOrEqual: () => St,
        IsLower: () => Mt,
        IsLowerOrEqual: () => bt,
        IsModelEmpty: () => Vt,
        IsNegative: () => qe,
        IsPositive: () => Se,
        IsPowerOfTwo: () => Oi,
        IsSolid: () => mn,
        IsUrl: () => gn,
        IsZero: () => lt,
        LinearToSRGB: () => dt,
        LinearTweenFunction: () => bn,
        LoadExternalLibrary: () => pe,
        MaterialBase: () => Mr,
        MaterialType: () => se,
        Matrix: () => L,
        MatrixIsEqual: () => ei,
        Mesh: () => k,
        MeshBuffer: () => Vr,
        MeshInstance: () => ft,
        MeshInstanceId: () => Xe,
        MeshPrimitiveBuffer: () => Pr,
        MeshType: () => Le,
        Model: () => At,
        ModelObject3D: () => Oe,
        ModelToThreeConversionOutput: () => dr,
        ModelToThreeConversionParams: () => fr,
        MouseInteraction: () => Ur,
        NameFromLine: () => He,
        Navigation: () => pr,
        NavigationType: () => me,
        NextPowerOfTwo: () => xn,
        Node: () => ue,
        NodeType: () => Me,
        Object3D: () => yr,
        Octree: () => Dt,
        OctreeNode: () => ct,
        ParabolicTweenFunction: () => Ei,
        ParameterConverter: () => Q,
        ParameterListBuilder: () => jr,
        ParameterListParser: () => Wr,
        ParametersFromLine: () => Ne,
        PhongMaterial: () => q,
        PhysicalMaterial: () => _e,
        Property: () => J,
        PropertyGroup: () => ae,
        PropertyToString: () => fi,
        PropertyType: () => X,
        Quaternion: () => oe,
        QuaternionFromAxisAngle: () => $r,
        QuaternionFromXYZ: () => ln,
        QuaternionIsEqual: () => sn,
        RadDeg: () => tn,
        ReadFile: () => ai,
        ReadLines: () => ve,
        ReplaceDefaultMaterialColor: () => pn,
        RequestUrl: () => li,
        RevokeObjectUrl: () => Qr,
        RunTaskAsync: () => Ar,
        RunTasks: () => ni,
        RunTasksBatch: () => oi,
        SRGBToLinear: () => Ue,
        SetDomElementHeight: () => Ji,
        SetDomElementOuterHeight: () => Pn,
        SetDomElementOuterWidth: () => Dn,
        SetDomElementWidth: () => Yi,
        SetExternalLibLocation: () => Tn,
        SetThreeMeshPolygonOffset: () => Ai,
        ShadingModel: () => kr,
        ShadingType: () => fe,
        ShowDomElement: () => Gn,
        SubCoord2D: () => Ir,
        SubCoord3D: () => ne,
        TaskRunner: () => Bt,
        TextWriter: () => Ce,
        TextureIsEqual: () => fn,
        TextureMap: () => ce,
        TextureMapIsEqual: () => tt,
        ThreeConversionStateHandler: () => Lr,
        ThreeModelLoader: () => mr,
        ThreeNodeTree: () => Br,
        Topology: () => Pt,
        TopologyEdge: () => Sr,
        TopologyTriangle: () => vr,
        TopologyTriangleEdge: () => wr,
        TopologyVertex: () => br,
        TouchInteraction: () => zr,
        TransformFileHostUrls: () => ui,
        TransformMesh: () => Be,
        Transformation: () => H,
        TransformationIsEqual: () => an,
        TraverseThreeObject: () => Ri,
        Triangle: () => z,
        TweenCoord3D: () => cr,
        UpVector: () => Hr,
        UpdateMaterialTransparency: () => le,
        Utf8StringToArrayBuffer: () => vt,
        ValueOrDefault: () => we,
        VectorAngle3D: () => Kr,
        VectorLength3D: () => wt,
        Viewer: () => Cr,
        ViewerExtraGeometry: () => gr,
        ViewerGeometry: () => xr,
        WaitWhile: () => si,
    });
    var $i = 1e-8,
        en = 1e-4,
        tn = 57.29577951308232,
        Ze = 0.017453292519943;
    function lt(s) {
        return Math.abs(s) < 1e-8;
    }
    function Mt(s, e) {
        return e - s > 1e-8;
    }
    function Yr(s, e) {
        return s - e > 1e-8;
    }
    function bt(s, e) {
        return e - s > -1e-8;
    }
    function St(s, e) {
        return s - e > -1e-8;
    }
    function U(s, e) {
        return Math.abs(e - s) < 1e-8;
    }
    function rn(s, e, t) {
        return Math.abs(e - s) < t;
    }
    function Se(s) {
        return s > 1e-8;
    }
    function qe(s) {
        return s < -1e-8;
    }
    var w = { X: 1, Y: 2, Z: 3 };
    var y = class {
        constructor(e, t, r) {
            (this.x = e), (this.y = t), (this.z = r);
        }
        Length() {
            return Math.sqrt(
                this.x * this.x + this.y * this.y + this.z * this.z
            );
        }
        MultiplyScalar(e) {
            return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        Normalize() {
            let e = this.Length();
            return e > 0 && this.MultiplyScalar(1 / e), this;
        }
        Offset(e, t) {
            let r = e.Clone().Normalize();
            return (
                (this.x += r.x * t),
                (this.y += r.y * t),
                (this.z += r.z * t),
                this
            );
        }
        Rotate(e, t, r) {
            let i = e.Clone().Normalize(),
                n = i.x,
                o = i.y,
                l = i.z,
                a = this.x - r.x,
                u = this.y - r.y,
                h = this.z - r.z,
                f = Math.sin(t),
                d = Math.cos(t);
            return (
                (this.x =
                    -n * (-n * a - o * u - l * h) * (1 - d) +
                    a * d +
                    (-l * u + o * h) * f),
                (this.y =
                    -o * (-n * a - o * u - l * h) * (1 - d) +
                    u * d +
                    (l * a - n * h) * f),
                (this.z =
                    -l * (-n * a - o * u - l * h) * (1 - d) +
                    h * d +
                    (-o * a + n * u) * f),
                (this.x += r.x),
                (this.y += r.y),
                (this.z += r.z),
                this
            );
        }
        Clone() {
            return new y(this.x, this.y, this.z);
        }
    };
    function ye(s, e) {
        return U(s.x, e.x) && U(s.y, e.y) && U(s.z, e.z);
    }
    function Jr(s, e) {
        return new y(s.x + e.x, s.y + e.y, s.z + e.z);
    }
    function ne(s, e) {
        return new y(s.x - e.x, s.y - e.y, s.z - e.z);
    }
    function Ie(s, e) {
        return Math.sqrt(
            (s.x - e.x) * (s.x - e.x) +
                (s.y - e.y) * (s.y - e.y) +
                (s.z - e.z) * (s.z - e.z)
        );
    }
    function Tr(s, e) {
        return s.x * e.x + s.y * e.y + s.z * e.z;
    }
    function Kr(s, e) {
        let t = s.Clone().Normalize(),
            r = e.Clone().Normalize();
        if (ye(t, r)) return 0;
        let i = Tr(t, r);
        return Math.acos(i);
    }
    function Ge(s, e) {
        let t = new y(0, 0, 0);
        return (
            (t.x = s.y * e.z - s.z * e.y),
            (t.y = s.z * e.x - s.x * e.z),
            (t.z = s.x * e.y - s.y * e.x),
            t
        );
    }
    function wt(s, e, t) {
        return Math.sqrt(s * s + e * e + t * t);
    }
    function Re(s) {
        return new y(s[0], s[1], s[2]);
    }
    function K(s) {
        return new TextDecoder("utf-8").decode(s);
    }
    function nn(s) {
        let e = "",
            t = new Uint8Array(s);
        for (let r = 0; r < t.byteLength; r++) e += String.fromCharCode(t[r]);
        return e;
    }
    function on(s) {
        let e = new ArrayBuffer(s.length),
            t = new Uint8Array(e);
        for (let r = 0; r < s.length; r++) t[r] = s.charCodeAt(r);
        return e;
    }
    function vt(s) {
        return new TextEncoder().encode(s).buffer;
    }
    function at(s) {
        let e = "data:";
        if (!s.startsWith(e)) return null;
        let t = s.indexOf(";");
        if (t === -1) return null;
        let r = s.indexOf(",");
        if (r === -1) return null;
        let i = s.substring(e.length, e.length + t - 5),
            n = atob(s.substring(r + 1)),
            o = new ArrayBuffer(n.length),
            l = new Uint8Array(o);
        for (let a = 0; a < n.length; a++) l[a] = n.charCodeAt(a);
        return { mimeType: i, buffer: o };
    }
    function Qe(s) {
        if (s == null) return "";
        let e = s.split("/");
        return e.length === 0 ? "" : e[e.length - 1];
    }
    function ut(s) {
        let e = new Blob([s]);
        return URL.createObjectURL(e);
    }
    function Zr(s, e) {
        let t = new Blob([s], { type: e });
        return URL.createObjectURL(t);
    }
    function Qr(s) {
        URL.revokeObjectURL(s);
    }
    var yr = class {
            constructor() {}
            VertexCount() {
                return 0;
            }
            VertexColorCount() {
                return 0;
            }
            NormalCount() {
                return 0;
            }
            TextureUVCount() {
                return 0;
            }
            TriangleCount() {
                return 0;
            }
            EnumerateVertices(e) {}
            EnumerateTriangleVertexIndices(e) {}
            EnumerateTriangleVertices(e) {}
        },
        Oe = class extends yr {
            constructor() {
                super(), (this.name = ""), (this.propertyGroups = []);
            }
            GetName() {
                return this.name;
            }
            SetName(e) {
                this.name = e;
            }
            PropertyGroupCount() {
                return this.propertyGroups.length;
            }
            AddPropertyGroup(e) {
                return (
                    this.propertyGroups.push(e), this.propertyGroups.length - 1
                );
            }
            GetPropertyGroup(e) {
                return this.propertyGroups[e];
            }
            CloneProperties(e) {
                for (let t of this.propertyGroups)
                    e.AddPropertyGroup(t.Clone());
            }
        };
    var k = class extends Oe {
        constructor() {
            super(),
                (this.vertices = []),
                (this.vertexColors = []),
                (this.normals = []),
                (this.uvs = []),
                (this.triangles = []);
        }
        VertexCount() {
            return this.vertices.length;
        }
        VertexColorCount() {
            return this.vertexColors.length;
        }
        NormalCount() {
            return this.normals.length;
        }
        TextureUVCount() {
            return this.uvs.length;
        }
        TriangleCount() {
            return this.triangles.length;
        }
        AddVertex(e) {
            return this.vertices.push(e), this.vertices.length - 1;
        }
        SetVertex(e, t) {
            this.vertices[e] = t;
        }
        GetVertex(e) {
            return this.vertices[e];
        }
        AddVertexColor(e) {
            return this.vertexColors.push(e), this.vertexColors.length - 1;
        }
        SetVertexColor(e, t) {
            this.vertexColors[e] = t;
        }
        GetVertexColor(e) {
            return this.vertexColors[e];
        }
        AddNormal(e) {
            return this.normals.push(e), this.normals.length - 1;
        }
        SetNormal(e, t) {
            this.normals[e] = t;
        }
        GetNormal(e) {
            return this.normals[e];
        }
        AddTextureUV(e) {
            return this.uvs.push(e), this.uvs.length - 1;
        }
        SetTextureUV(e, t) {
            this.uvs[e] = t;
        }
        GetTextureUV(e) {
            return this.uvs[e];
        }
        AddTriangle(e) {
            return this.triangles.push(e), this.triangles.length - 1;
        }
        GetTriangle(e) {
            return this.triangles[e];
        }
        EnumerateVertices(e) {
            for (let t of this.vertices) e(t);
        }
        EnumerateTriangleVertexIndices(e) {
            for (let t of this.triangles) e(t.v0, t.v1, t.v2);
        }
        EnumerateTriangleVertices(e) {
            for (let t of this.triangles) {
                let r = this.vertices[t.v0],
                    i = this.vertices[t.v1],
                    n = this.vertices[t.v2];
                e(r, i, n);
            }
        }
        Clone() {
            let e = new k();
            e.SetName(this.GetName()), this.CloneProperties(e);
            for (let t = 0; t < this.VertexCount(); t++) {
                let r = this.GetVertex(t);
                e.AddVertex(r.Clone());
            }
            for (let t = 0; t < this.VertexColorCount(); t++) {
                let r = this.GetVertexColor(t);
                e.AddVertexColor(r.Clone());
            }
            for (let t = 0; t < this.NormalCount(); t++) {
                let r = this.GetNormal(t);
                e.AddNormal(r.Clone());
            }
            for (let t = 0; t < this.TextureUVCount(); t++) {
                let r = this.GetTextureUV(t);
                e.AddTextureUV(r.Clone());
            }
            for (let t = 0; t < this.TriangleCount(); t++) {
                let r = this.GetTriangle(t);
                e.AddTriangle(r.Clone());
            }
            return e;
        }
    };
    var z = class {
        constructor(e, t, r) {
            (this.v0 = e),
                (this.v1 = t),
                (this.v2 = r),
                (this.c0 = null),
                (this.c1 = null),
                (this.c2 = null),
                (this.n0 = null),
                (this.n1 = null),
                (this.n2 = null),
                (this.u0 = null),
                (this.u1 = null),
                (this.u2 = null),
                (this.mat = null),
                (this.curve = null);
        }
        HasVertices() {
            return this.v0 !== null && this.v1 !== null && this.v2 !== null;
        }
        HasVertexColors() {
            return this.c0 !== null && this.c1 !== null && this.c2 !== null;
        }
        HasNormals() {
            return this.n0 !== null && this.n1 !== null && this.n2 !== null;
        }
        HasTextureUVs() {
            return this.u0 !== null && this.u1 !== null && this.u2 !== null;
        }
        SetVertices(e, t, r) {
            return (this.v0 = e), (this.v1 = t), (this.v2 = r), this;
        }
        SetVertexColors(e, t, r) {
            return (this.c0 = e), (this.c1 = t), (this.c2 = r), this;
        }
        SetNormals(e, t, r) {
            return (this.n0 = e), (this.n1 = t), (this.n2 = r), this;
        }
        SetTextureUVs(e, t, r) {
            return (this.u0 = e), (this.u1 = t), (this.u2 = r), this;
        }
        SetMaterial(e) {
            return (this.mat = e), this;
        }
        SetCurve(e) {
            return (this.curve = e), this;
        }
        Clone() {
            let e = new z(this.v0, this.v1, this.v2);
            return (
                e.SetVertexColors(this.c0, this.c1, this.c2),
                e.SetNormals(this.n0, this.n1, this.n2),
                e.SetTextureUVs(this.u0, this.u1, this.u2),
                e.SetMaterial(this.mat),
                e.SetCurve(this.curve),
                e
            );
        }
    };
    var Ee = class {
        constructor(e, t, r, i) {
            (this.x = e), (this.y = t), (this.z = r), (this.w = i);
        }
        Clone() {
            return new Ee(this.x, this.y, this.z, this.w);
        }
    };
    var oe = class {
        constructor(e, t, r, i) {
            (this.x = e), (this.y = t), (this.z = r), (this.w = i);
        }
    };
    function sn(s, e) {
        return U(s.x, e.x) && U(s.y, e.y) && U(s.z, e.z) && U(s.w, e.w);
    }
    function $e(s) {
        return new oe(s[0], s[1], s[2], s[3]);
    }
    function $r(s, e) {
        let t = e / 2,
            r = Math.sin(t);
        return new oe(s.x * r, s.y * r, s.z * r, Math.cos(t));
    }
    function ln(s, e, t, r) {
        let i = Math.cos(s / 2),
            n = Math.cos(e / 2),
            o = Math.cos(t / 2),
            l = Math.sin(s / 2),
            a = Math.sin(e / 2),
            u = Math.sin(t / 2),
            h = new oe(0, 0, 0, 1);
        if (r === "XYZ")
            (h.x = l * n * o + i * a * u),
                (h.y = i * a * o - l * n * u),
                (h.z = i * n * u + l * a * o),
                (h.w = i * n * o - l * a * u);
        else if (r === "YXZ")
            (h.x = l * n * o + i * a * u),
                (h.y = i * a * o - l * n * u),
                (h.z = i * n * u - l * a * o),
                (h.w = i * n * o + l * a * u);
        else if (r === "ZXY")
            (h.x = l * n * o - i * a * u),
                (h.y = i * a * o + l * n * u),
                (h.z = i * n * u + l * a * o),
                (h.w = i * n * o - l * a * u);
        else if (r === "ZYX")
            (h.x = l * n * o - i * a * u),
                (h.y = i * a * o + l * n * u),
                (h.z = i * n * u - l * a * o),
                (h.w = i * n * o + l * a * u);
        else if (r === "YZX")
            (h.x = l * n * o + i * a * u),
                (h.y = i * a * o + l * n * u),
                (h.z = i * n * u - l * a * o),
                (h.w = i * n * o - l * a * u);
        else if (r === "XZY")
            (h.x = l * n * o - i * a * u),
                (h.y = i * a * o - l * n * u),
                (h.z = i * n * u + l * a * o),
                (h.w = i * n * o + l * a * u);
        else return null;
        return h;
    }
    var L = class {
        constructor(e) {
            (this.matrix = null), e != null && (this.matrix = e);
        }
        IsValid() {
            return this.matrix !== null;
        }
        Set(e) {
            return (this.matrix = e), this;
        }
        Get() {
            return this.matrix;
        }
        Clone() {
            let e = [
                this.matrix[0],
                this.matrix[1],
                this.matrix[2],
                this.matrix[3],
                this.matrix[4],
                this.matrix[5],
                this.matrix[6],
                this.matrix[7],
                this.matrix[8],
                this.matrix[9],
                this.matrix[10],
                this.matrix[11],
                this.matrix[12],
                this.matrix[13],
                this.matrix[14],
                this.matrix[15],
            ];
            return new L(e);
        }
        CreateIdentity() {
            return (
                (this.matrix = [
                    1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
                ]),
                this
            );
        }
        IsIdentity() {
            let e = new L().CreateIdentity().Get();
            for (let t = 0; t < 16; t++)
                if (!U(this.matrix[t], e[t])) return !1;
            return !0;
        }
        CreateTranslation(e, t, r) {
            return (
                (this.matrix = [
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    e,
                    t,
                    r,
                    1,
                ]),
                this
            );
        }
        CreateRotation(e, t, r, i) {
            let n = e + e,
                o = t + t,
                l = r + r,
                a = e * n,
                u = e * o,
                h = e * l,
                f = t * o,
                d = t * l,
                c = r * l,
                p = i * n,
                m = i * o,
                x = i * l;
            return (
                (this.matrix = [
                    1 - (f + c),
                    u + x,
                    h - m,
                    0,
                    u - x,
                    1 - (a + c),
                    d + p,
                    0,
                    h + m,
                    d - p,
                    1 - (a + f),
                    0,
                    0,
                    0,
                    0,
                    1,
                ]),
                this
            );
        }
        CreateRotationAxisAngle(e, t) {
            let r = $r(e, t);
            return this.CreateRotation(r.x, r.y, r.z, r.w);
        }
        CreateScale(e, t, r) {
            return (
                (this.matrix = [
                    e,
                    0,
                    0,
                    0,
                    0,
                    t,
                    0,
                    0,
                    0,
                    0,
                    r,
                    0,
                    0,
                    0,
                    0,
                    1,
                ]),
                this
            );
        }
        ComposeTRS(e, t, r) {
            let i = e.x,
                n = e.y,
                o = e.z,
                l = t.x,
                a = t.y,
                u = t.z,
                h = t.w,
                f = r.x,
                d = r.y,
                c = r.z,
                p = l + l,
                m = a + a,
                x = u + u,
                g = l * p,
                C = l * m,
                E = l * x,
                T = a * m,
                M = a * x,
                S = u * x,
                I = h * p,
                v = h * m,
                b = h * x;
            return (
                (this.matrix = [
                    (1 - (T + S)) * f,
                    (C + b) * f,
                    (E - v) * f,
                    0,
                    (C - b) * d,
                    (1 - (g + S)) * d,
                    (M + I) * d,
                    0,
                    (E + v) * c,
                    (M - I) * c,
                    (1 - (g + T)) * c,
                    0,
                    i,
                    n,
                    o,
                    1,
                ]),
                this
            );
        }
        DecomposeTRS() {
            let e = new y(this.matrix[12], this.matrix[13], this.matrix[14]),
                t = wt(this.matrix[0], this.matrix[1], this.matrix[2]),
                r = wt(this.matrix[4], this.matrix[5], this.matrix[6]),
                i = wt(this.matrix[8], this.matrix[9], this.matrix[10]),
                n = this.Determinant();
            qe(n) && (t *= -1);
            let o = new y(t, r, i),
                l = this.matrix[0] / t,
                a = this.matrix[4] / r,
                u = this.matrix[8] / i,
                h = this.matrix[1] / t,
                f = this.matrix[5] / r,
                d = this.matrix[9] / i,
                c = this.matrix[2] / t,
                p = this.matrix[6] / r,
                m = this.matrix[10] / i,
                x = null,
                g = l + f + m;
            if (g > 0) {
                let C = Math.sqrt(g + 1) * 2;
                x = new oe((p - d) / C, (u - c) / C, (h - a) / C, 0.25 * C);
            } else if (l > f && l > m) {
                let C = Math.sqrt(1 + l - f - m) * 2;
                x = new oe(0.25 * C, (a + h) / C, (u + c) / C, (p - d) / C);
            } else if (f > m) {
                let C = Math.sqrt(1 + f - l - m) * 2;
                x = new oe((a + h) / C, 0.25 * C, (d + p) / C, (u - c) / C);
            } else {
                let C = Math.sqrt(1 + m - l - f) * 2;
                x = new oe((u + c) / C, (d + p) / C, 0.25 * C, (h - a) / C);
            }
            return { translation: e, rotation: x, scale: o };
        }
        Determinant() {
            let e = this.matrix[0],
                t = this.matrix[1],
                r = this.matrix[2],
                i = this.matrix[3],
                n = this.matrix[4],
                o = this.matrix[5],
                l = this.matrix[6],
                a = this.matrix[7],
                u = this.matrix[8],
                h = this.matrix[9],
                f = this.matrix[10],
                d = this.matrix[11],
                c = this.matrix[12],
                p = this.matrix[13],
                m = this.matrix[14],
                x = this.matrix[15],
                g = e * o - t * n,
                C = e * l - r * n,
                E = e * a - i * n,
                T = t * l - r * o,
                M = t * a - i * o,
                S = r * a - i * l,
                I = u * p - h * c,
                v = u * m - f * c,
                b = u * x - d * c,
                G = h * m - f * p,
                P = h * x - d * p,
                N = f * x - d * m;
            return g * N - C * P + E * G + T * b - M * v + S * I;
        }
        Invert() {
            let e = this.matrix[0],
                t = this.matrix[1],
                r = this.matrix[2],
                i = this.matrix[3],
                n = this.matrix[4],
                o = this.matrix[5],
                l = this.matrix[6],
                a = this.matrix[7],
                u = this.matrix[8],
                h = this.matrix[9],
                f = this.matrix[10],
                d = this.matrix[11],
                c = this.matrix[12],
                p = this.matrix[13],
                m = this.matrix[14],
                x = this.matrix[15],
                g = e * o - t * n,
                C = e * l - r * n,
                E = e * a - i * n,
                T = t * l - r * o,
                M = t * a - i * o,
                S = r * a - i * l,
                I = u * p - h * c,
                v = u * m - f * c,
                b = u * x - d * c,
                G = h * m - f * p,
                P = h * x - d * p,
                N = f * x - d * m,
                D = g * N - C * P + E * G + T * b - M * v + S * I;
            if (U(D, 0)) return null;
            let V = [
                (o * N - l * P + a * G) / D,
                (r * P - t * N - i * G) / D,
                (p * S - m * M + x * T) / D,
                (f * M - h * S - d * T) / D,
                (l * b - n * N - a * v) / D,
                (e * N - r * b + i * v) / D,
                (m * E - c * S - x * C) / D,
                (u * S - f * E + d * C) / D,
                (n * P - o * b + a * I) / D,
                (t * b - e * P - i * I) / D,
                (c * M - p * E + x * g) / D,
                (h * E - u * M - d * g) / D,
                (o * v - n * G - l * I) / D,
                (e * G - t * v + r * I) / D,
                (p * C - c * T - m * g) / D,
                (u * T - h * C + f * g) / D,
            ];
            return new L(V);
        }
        Transpose() {
            let e = [
                this.matrix[0],
                this.matrix[4],
                this.matrix[8],
                this.matrix[12],
                this.matrix[1],
                this.matrix[5],
                this.matrix[9],
                this.matrix[13],
                this.matrix[2],
                this.matrix[6],
                this.matrix[10],
                this.matrix[14],
                this.matrix[3],
                this.matrix[7],
                this.matrix[11],
                this.matrix[15],
            ];
            return new L(e);
        }
        InvertTranspose() {
            let e = this.Invert();
            return e === null ? null : e.Transpose();
        }
        MultiplyVector(e) {
            let t = e.x,
                r = e.y,
                i = e.z,
                n = e.w,
                o = this.matrix[0],
                l = this.matrix[1],
                a = this.matrix[2],
                u = this.matrix[3],
                h = this.matrix[4],
                f = this.matrix[5],
                d = this.matrix[6],
                c = this.matrix[7],
                p = this.matrix[8],
                m = this.matrix[9],
                x = this.matrix[10],
                g = this.matrix[11],
                C = this.matrix[12],
                E = this.matrix[13],
                T = this.matrix[14],
                M = this.matrix[15];
            return new Ee(
                t * o + r * h + i * p + n * C,
                t * l + r * f + i * m + n * E,
                t * a + r * d + i * x + n * T,
                t * u + r * c + i * g + n * M
            );
        }
        MultiplyMatrix(e) {
            let t = this.matrix[0],
                r = this.matrix[1],
                i = this.matrix[2],
                n = this.matrix[3],
                o = this.matrix[4],
                l = this.matrix[5],
                a = this.matrix[6],
                u = this.matrix[7],
                h = this.matrix[8],
                f = this.matrix[9],
                d = this.matrix[10],
                c = this.matrix[11],
                p = this.matrix[12],
                m = this.matrix[13],
                x = this.matrix[14],
                g = this.matrix[15],
                C = e.matrix[0],
                E = e.matrix[1],
                T = e.matrix[2],
                M = e.matrix[3],
                S = e.matrix[4],
                I = e.matrix[5],
                v = e.matrix[6],
                b = e.matrix[7],
                G = e.matrix[8],
                P = e.matrix[9],
                N = e.matrix[10],
                D = e.matrix[11],
                V = e.matrix[12],
                Y = e.matrix[13],
                O = e.matrix[14],
                Te = e.matrix[15],
                Ve = [
                    t * C + r * S + i * G + n * V,
                    t * E + r * I + i * P + n * Y,
                    t * T + r * v + i * N + n * O,
                    t * M + r * b + i * D + n * Te,
                    o * C + l * S + a * G + u * V,
                    o * E + l * I + a * P + u * Y,
                    o * T + l * v + a * N + u * O,
                    o * M + l * b + a * D + u * Te,
                    h * C + f * S + d * G + c * V,
                    h * E + f * I + d * P + c * Y,
                    h * T + f * v + d * N + c * O,
                    h * M + f * b + d * D + c * Te,
                    p * C + m * S + x * G + g * V,
                    p * E + m * I + x * P + g * Y,
                    p * T + m * v + x * N + g * O,
                    p * M + m * b + x * D + g * Te,
                ];
            return new L(Ve);
        }
    };
    function ei(s, e) {
        let t = s.Get(),
            r = e.Get();
        for (let i = 0; i < 16; i++) if (!U(t[i], r[i])) return !1;
        return !0;
    }
    var H = class {
        constructor(e) {
            e != null
                ? (this.matrix = e)
                : ((this.matrix = new L()), this.matrix.CreateIdentity());
        }
        SetMatrix(e) {
            return (this.matrix = e), this;
        }
        GetMatrix() {
            return this.matrix;
        }
        IsIdentity() {
            return this.matrix.IsIdentity();
        }
        AppendMatrix(e) {
            return (this.matrix = this.matrix.MultiplyMatrix(e)), this;
        }
        Append(e) {
            return this.AppendMatrix(e.GetMatrix()), this;
        }
        TransformCoord3D(e) {
            let t = new Ee(e.x, e.y, e.z, 1),
                r = this.matrix.MultiplyVector(t);
            return new y(r.x, r.y, r.z);
        }
        Clone() {
            let e = this.matrix.Clone();
            return new H(e);
        }
    };
    function an(s, e) {
        return ei(s.GetMatrix(), e.GetMatrix());
    }
    var Le = { Empty: 0, TriangleMesh: 1 };
    function et(s) {
        return s.TriangleCount() > 0 ? Le.TriangleMesh : Le.Empty;
    }
    function ht(s, e, t) {
        let r = ne(e, s),
            i = ne(t, s),
            n = Ge(r, i);
        return n.Normalize(), n;
    }
    function Be(s, e) {
        if (!e.IsIdentity()) {
            for (let t = 0; t < s.VertexCount(); t++) {
                let r = s.GetVertex(t),
                    i = e.TransformCoord3D(r);
                (r.x = i.x), (r.y = i.y), (r.z = i.z);
            }
            if (s.NormalCount() > 0) {
                let t = e.GetMatrix().InvertTranspose();
                if (t !== null) {
                    let r = new H(t);
                    for (let i = 0; i < s.NormalCount(); i++) {
                        let n = s.GetNormal(i),
                            o = r.TransformCoord3D(n);
                        (n.x = o.x), (n.y = o.y), (n.z = o.z);
                    }
                }
            }
        }
    }
    function ti(s) {
        for (let e = 0; e < s.TriangleCount(); e++) {
            let t = s.GetTriangle(e),
                r = t.v1;
            (t.v1 = t.v2), (t.v2 = r);
        }
    }
    var Xe = class {
            constructor(e, t) {
                (this.nodeId = e), (this.meshIndex = t);
            }
            IsEqual(e) {
                return (
                    this.nodeId === e.nodeId && this.meshIndex === e.meshIndex
                );
            }
            GetKey() {
                return this.nodeId.toString() + ":" + this.meshIndex.toString();
            }
        },
        ft = class extends Oe {
            constructor(e, t, r) {
                super(), (this.id = e), (this.node = t), (this.mesh = r);
            }
            GetId() {
                return this.id;
            }
            GetTransformation() {
                return this.node.GetWorldTransformation();
            }
            GetMesh() {
                return this.mesh;
            }
            VertexCount() {
                return this.mesh.VertexCount();
            }
            VertexColorCount() {
                return this.mesh.VertexColorCount();
            }
            NormalCount() {
                return this.mesh.NormalCount();
            }
            TextureUVCount() {
                return this.mesh.TextureUVCount();
            }
            TriangleCount() {
                return this.mesh.TriangleCount();
            }
            EnumerateVertices(e) {
                let t = this.node.GetWorldTransformation();
                t.IsIdentity()
                    ? this.mesh.EnumerateVertices(e)
                    : this.mesh.EnumerateVertices((r) => {
                          let i = t.TransformCoord3D(r);
                          e(i);
                      });
            }
            EnumerateTriangleVertexIndices(e) {
                this.mesh.EnumerateTriangleVertexIndices(e);
            }
            EnumerateTriangleVertices(e) {
                let t = this.node.GetWorldTransformation();
                t.IsIdentity()
                    ? this.mesh.EnumerateTriangleVertices(e)
                    : this.mesh.EnumerateTriangleVertices((r, i, n) => {
                          let o = t.TransformCoord3D(r),
                              l = t.TransformCoord3D(i),
                              a = t.TransformCoord3D(n);
                          e(o, l, a);
                      });
            }
            PropertyGroupCount() {
                return this.mesh.PropertyGroupCount();
            }
            AddPropertyGroup(e) {
                return this.mesh.AddPropertyGroup(e);
            }
            GetPropertyGroup(e) {
                return this.mesh.GetPropertyGroup(e);
            }
            GetTransformedMesh() {
                let e = this.node.GetWorldTransformation(),
                    t = this.mesh.Clone();
                return Be(t, e), t;
            }
        };
    var Ni = class {
            constructor() {
                this.nextId = 0;
            }
            GenerateId() {
                let e = this.nextId;
                return (this.nextId += 1), e;
            }
        },
        Me = { GroupNode: 0, MeshNode: 1 },
        ue = class {
            constructor() {
                (this.type = Me.GroupNode),
                    (this.name = ""),
                    (this.parent = null),
                    (this.transformation = new H()),
                    (this.childNodes = []),
                    (this.meshIndices = []),
                    (this.idGenerator = new Ni()),
                    (this.id = this.idGenerator.GenerateId());
            }
            IsEmpty() {
                return (
                    this.childNodes.length === 0 &&
                    this.meshIndices.length === 0
                );
            }
            GetType() {
                return this.type;
            }
            SetType(e) {
                this.type = e;
            }
            GetId() {
                return this.id;
            }
            GetName() {
                return this.name;
            }
            SetName(e) {
                this.name = e;
            }
            HasParent() {
                return this.parent !== null;
            }
            GetParent() {
                return this.parent;
            }
            GetTransformation() {
                return this.transformation;
            }
            GetWorldTransformation() {
                let e = this.transformation.Clone(),
                    t = this.parent;
                for (; t !== null; ) e.Append(t.transformation), (t = t.parent);
                return e;
            }
            SetTransformation(e) {
                this.transformation = e;
            }
            AddChildNode(e) {
                return (
                    (e.parent = this),
                    (e.idGenerator = this.idGenerator),
                    (e.id = e.idGenerator.GenerateId()),
                    this.childNodes.push(e),
                    this.childNodes.length - 1
                );
            }
            RemoveChildNode(e) {
                e.parent = null;
                let t = this.childNodes.indexOf(e);
                this.childNodes.splice(t, 1);
            }
            GetChildNodes() {
                return this.childNodes;
            }
            ChildNodeCount() {
                return this.childNodes.length;
            }
            GetChildNode(e) {
                return this.childNodes[e];
            }
            AddMeshIndex(e) {
                return this.meshIndices.push(e), this.meshIndices.length - 1;
            }
            MeshIndexCount() {
                return this.meshIndices.length;
            }
            GetMeshIndex(e) {
                return this.meshIndices[e];
            }
            GetMeshIndices() {
                return this.meshIndices;
            }
            Enumerate(e) {
                e(this);
                for (let t of this.childNodes) t.Enumerate(e);
            }
            EnumerateChildren(e) {
                for (let t of this.childNodes) e(t), t.EnumerateChildren(e);
            }
            EnumerateMeshIndices(e) {
                for (let t of this.meshIndices) e(t);
                for (let t of this.childNodes) t.EnumerateMeshIndices(e);
            }
        };
    var At = class extends Oe {
        constructor() {
            super(),
                (this.root = new ue()),
                (this.materials = []),
                (this.meshes = []);
        }
        GetRootNode() {
            return this.root;
        }
        MaterialCount() {
            return this.materials.length;
        }
        MeshCount() {
            return this.meshes.length;
        }
        MeshInstanceCount() {
            let e = 0;
            return (
                this.root.Enumerate((t) => {
                    e += t.MeshIndexCount();
                }),
                e
            );
        }
        VertexCount() {
            let e = 0;
            return (
                this.EnumerateMeshInstances((t) => {
                    e += t.VertexCount();
                }),
                e
            );
        }
        VertexColorCount() {
            let e = 0;
            return (
                this.EnumerateMeshInstances((t) => {
                    e += t.VertexColorCount();
                }),
                e
            );
        }
        NormalCount() {
            let e = 0;
            return (
                this.EnumerateMeshInstances((t) => {
                    e += t.NormalCount();
                }),
                e
            );
        }
        TextureUVCount() {
            let e = 0;
            return (
                this.EnumerateMeshInstances((t) => {
                    e += t.TextureUVCount();
                }),
                e
            );
        }
        TriangleCount() {
            let e = 0;
            return (
                this.EnumerateMeshInstances((t) => {
                    e += t.TriangleCount();
                }),
                e
            );
        }
        AddMaterial(e) {
            return this.materials.push(e), this.materials.length - 1;
        }
        GetMaterial(e) {
            return this.materials[e];
        }
        AddMesh(e) {
            return this.meshes.push(e), this.meshes.length - 1;
        }
        AddMeshToRootNode(e) {
            let t = this.AddMesh(e);
            return this.root.AddMeshIndex(t), t;
        }
        RemoveMesh(e) {
            this.meshes.splice(e, 1),
                this.root.Enumerate((t) => {
                    for (let r = 0; r < t.meshIndices.length; r++)
                        t.meshIndices[r] === e
                            ? (t.meshIndices.splice(r, 1), (r -= 1))
                            : t.meshIndices[r] > e && (t.meshIndices[r] -= 1);
                });
        }
        GetMesh(e) {
            return this.meshes[e];
        }
        GetMeshInstance(e) {
            let t = null;
            if (
                (this.root.Enumerate((o) => {
                    o.GetId() === e.nodeId && (t = o);
                }),
                t === null || t.GetMeshIndices().indexOf(e.meshIndex) === -1)
            )
                return null;
            let i = this.GetMesh(e.meshIndex),
                n = new Xe(t.GetId(), e.meshIndex);
            return new ft(n, t, i);
        }
        EnumerateMeshes(e) {
            for (let t of this.meshes) e(t);
        }
        EnumerateMeshInstances(e) {
            this.root.Enumerate((t) => {
                for (let r of t.GetMeshIndices()) {
                    let i = new Xe(t.GetId(), r),
                        n = this.GetMesh(r),
                        o = new ft(i, t, n);
                    e(o);
                }
            });
        }
        EnumerateTransformedMeshes(e) {
            this.EnumerateMeshInstances((t) => {
                let r = t.GetTransformedMesh();
                e(r);
            });
        }
        EnumerateVertices(e) {
            this.EnumerateMeshInstances((t) => {
                t.EnumerateVertices(e);
            });
        }
        EnumerateTriangleVertexIndices(e) {
            this.EnumerateMeshInstances((t) => {
                t.EnumerateTriangleVertexIndices(e);
            });
        }
        EnumerateTriangleVertices(e) {
            this.EnumerateMeshInstances((t) => {
                t.EnumerateTriangleVertices(e);
            });
        }
    };
    function Gt(s) {
        return s != null;
    }
    function we(s, e) {
        return s ?? e;
    }
    function Rt(s, e) {
        if (!!Gt(s)) for (let t of Object.keys(s)) Gt(s[t]) && (e[t] = s[t]);
    }
    var R = class {
        constructor(e, t, r) {
            (this.r = e), (this.g = t), (this.b = r);
        }
        Set(e, t, r) {
            (this.r = e), (this.g = t), (this.b = r);
        }
        Clone() {
            return new R(this.r, this.g, this.b);
        }
    };
    function he(s) {
        return parseInt(Math.round(s * 255), 10);
    }
    function be(s, e, t) {
        return new R(he(s), he(e), he(t));
    }
    function Ue(s) {
        return s < 0.04045
            ? s * 0.0773993808
            : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
    }
    function dt(s) {
        return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
    }
    function Z(s) {
        let e = parseInt(s, 10).toString(16);
        for (; e.length < 2; ) e = "0" + e;
        return e;
    }
    function ze(s) {
        let e = Z(s.r),
            t = Z(s.g),
            r = Z(s.b);
        return e + t + r;
    }
    function un(s) {
        if (s.length !== 6) return null;
        let e = parseInt(s.substring(0, 2), 16),
            t = parseInt(s.substring(2, 4), 16),
            r = parseInt(s.substring(4, 6), 16);
        return new R(e, t, r);
    }
    function ri(s) {
        return new R(s[0], s[1], s[2]);
    }
    function Ye(s, e) {
        return s.r === e.r && s.g === e.g && s.b === e.b;
    }
    var F = class {
        constructor(e, t) {
            (this.x = e), (this.y = t);
        }
        Clone() {
            return new F(this.x, this.y);
        }
    };
    function Fe(s, e) {
        return U(s.x, e.x) && U(s.y, e.y);
    }
    function hn(s, e) {
        return new F(s.x + e.x, s.y + e.y);
    }
    function Ir(s, e) {
        return new F(s.x - e.x, s.y - e.y);
    }
    function Er(s, e) {
        return Math.sqrt((s.x - e.x) * (s.x - e.x) + (s.y - e.y) * (s.y - e.y));
    }
    var ce = class {
        constructor() {
            (this.name = null),
                (this.mimeType = null),
                (this.buffer = null),
                (this.offset = new F(0, 0)),
                (this.scale = new F(1, 1)),
                (this.rotation = 0);
        }
        IsValid() {
            return this.name !== null && this.buffer !== null;
        }
        HasTransformation() {
            return (
                !Fe(this.offset, new F(0, 0)) ||
                !Fe(this.scale, new F(1, 1)) ||
                !U(this.rotation, 0)
            );
        }
        IsEqual(e) {
            return !(
                this.name !== e.name ||
                this.mimeType !== e.mimeType ||
                !Fe(this.offset, e.offset) ||
                !Fe(this.scale, e.scale) ||
                !U(this.rotation, e.rotation)
            );
        }
    };
    function tt(s, e) {
        return s === null && e === null
            ? !0
            : s === null || e === null
            ? !1
            : s.IsEqual(e);
    }
    var se = { Phong: 1, Physical: 2 },
        Mr = class {
            constructor(e) {
                (this.type = e),
                    (this.isDefault = !1),
                    (this.name = ""),
                    (this.color = new R(0, 0, 0)),
                    (this.vertexColors = !1);
            }
            IsEqual(e) {
                return !(
                    this.type !== e.type ||
                    this.isDefault !== e.isDefault ||
                    this.name !== e.name ||
                    !Ye(this.color, e.color) ||
                    this.vertexColors !== e.vertexColors
                );
            }
        },
        Ft = class extends Mr {
            constructor(e) {
                super(e),
                    (this.emissive = new R(0, 0, 0)),
                    (this.opacity = 1),
                    (this.transparent = !1),
                    (this.diffuseMap = null),
                    (this.bumpMap = null),
                    (this.normalMap = null),
                    (this.emissiveMap = null),
                    (this.alphaTest = 0),
                    (this.multiplyDiffuseMap = !1);
            }
            IsEqual(e) {
                return !(
                    !super.IsEqual(e) ||
                    !Ye(this.emissive, e.emissive) ||
                    !U(this.opacity, e.opacity) ||
                    this.transparent !== e.transparent ||
                    !tt(this.diffuseMap, e.diffuseMap) ||
                    !tt(this.bumpMap, e.bumpMap) ||
                    !tt(this.normalMap, e.normalMap) ||
                    !tt(this.emissiveMap, e.emissiveMap) ||
                    !U(this.alphaTest, e.alphaTest) ||
                    this.multiplyDiffuseMap !== e.multiplyDiffuseMap
                );
            }
        },
        q = class extends Ft {
            constructor() {
                super(se.Phong),
                    (this.ambient = new R(0, 0, 0)),
                    (this.specular = new R(0, 0, 0)),
                    (this.shininess = 0),
                    (this.specularMap = null);
            }
            IsEqual(e) {
                return !(
                    !super.IsEqual(e) ||
                    !Ye(this.ambient, e.ambient) ||
                    !Ye(this.specular, e.specular) ||
                    !U(this.shininess, e.shininess) ||
                    !tt(this.specularMap, e.specularMap)
                );
            }
        },
        _e = class extends Ft {
            constructor() {
                super(se.Physical),
                    (this.metalness = 0),
                    (this.roughness = 1),
                    (this.metalnessMap = null);
            }
            IsEqual(e) {
                return !(
                    !super.IsEqual(e) ||
                    !U(this.metalness, e.metalness) ||
                    !U(this.roughness, e.roughness) ||
                    !tt(this.metalnessMap, e.metalnessMap)
                );
            }
        };
    function fn(s, e) {
        return !(
            s.name !== e.name ||
            s.mimeType !== e.mimeType ||
            !Fe(s.offset, e.offset) ||
            !Fe(s.scale, e.scale) ||
            !U(s.rotation, e.rotation)
        );
    }
    var Di = class {
        constructor(e) {
            (this.params = { getDefaultMaterialColor: () => new R(0, 0, 0) }),
                Rt(e, this.params),
                (this.defaultMaterialIndex = null);
        }
        Finalize(e) {
            this.Reset(),
                this.FinalizeMeshes(e),
                this.FinalizeMaterials(e),
                this.FinalizeNodes(e);
        }
        FinalizeMaterials(e) {
            if (e.VertexColorCount() === 0) return;
            let t = new Map();
            for (let r = 0; r < e.MeshCount(); r++) {
                let i = e.GetMesh(r);
                for (let n = 0; n < i.TriangleCount(); n++) {
                    let o = i.GetTriangle(n),
                        l = o.HasVertexColors();
                    t.has(o.mat) ? l || t.set(o.mat, !1) : t.set(o.mat, l);
                }
            }
            for (let [r, i] of t) {
                let n = e.GetMaterial(r);
                n.vertexColors = i;
            }
        }
        FinalizeMeshes(e) {
            for (let t = 0; t < e.MeshCount(); t++) {
                let r = e.GetMesh(t);
                if (et(r) === Le.Empty) {
                    e.RemoveMesh(t), (t = t - 1);
                    continue;
                }
                this.FinalizeMesh(e, r);
            }
        }
        FinalizeMesh(e, t) {
            function r(n) {
                function o(u, h, f, d, c) {
                    function p(C, E) {
                        for (let T = 0; T < C.length; T++) {
                            let M = C[T];
                            if (ye(M, E)) return !0;
                        }
                        return !1;
                    }
                    let m = [],
                        x = c.get(f);
                    for (let C = 0; C < x.length; C++) {
                        let E = x[C],
                            T = u.GetTriangle(E);
                        if (h.curve === T.curve) {
                            let M = d[E];
                            p(m, M) || m.push(M);
                        }
                    }
                    let g = new y(0, 0, 0);
                    for (let C = 0; C < m.length; C++) g = Jr(g, m[C]);
                    return (
                        g.MultiplyScalar(1 / m.length),
                        g.Normalize(),
                        u.AddNormal(g)
                    );
                }
                let l = [],
                    a = new Map();
                for (let u = 0; u < n.VertexCount(); u++) a.set(u, []);
                for (let u = 0; u < n.TriangleCount(); u++) {
                    let h = n.GetTriangle(u),
                        f = n.GetVertex(h.v0),
                        d = n.GetVertex(h.v1),
                        c = n.GetVertex(h.v2),
                        p = ht(f, d, c);
                    l.push(p),
                        a.get(h.v0).push(u),
                        a.get(h.v1).push(u),
                        a.get(h.v2).push(u);
                }
                for (let u = 0; u < n.TriangleCount(); u++) {
                    let h = n.GetTriangle(u);
                    if (!h.HasNormals()) {
                        let f = o(n, h, h.v0, l, a),
                            d = o(n, h, h.v1, l, a),
                            c = o(n, h, h.v2, l, a);
                        h.SetNormals(f, d, c);
                    }
                }
            }
            let i = { calculateCurveNormals: !1 };
            for (let n = 0; n < t.TriangleCount(); n++) {
                let o = t.GetTriangle(n);
                this.FinalizeTriangle(t, o, i),
                    o.mat === null && (o.mat = this.GetDefaultMaterialIndex(e));
            }
            i.calculateCurveNormals && r(t);
        }
        FinalizeTriangle(e, t, r) {
            if (!t.HasNormals())
                if (t.curve === null || t.curve === 0) {
                    let i = e.GetVertex(t.v0),
                        n = e.GetVertex(t.v1),
                        o = e.GetVertex(t.v2),
                        l = ht(i, n, o),
                        a = e.AddNormal(l);
                    t.SetNormals(a, a, a);
                } else r.calculateCurveNormals = !0;
            t.curve === null && (t.curve = 0);
        }
        FinalizeNodes(e) {
            let t = e.GetRootNode(),
                r = [];
            t.EnumerateChildren((i) => {
                i.IsEmpty() && r.push(i);
            });
            for (let i = 0; i < r.length; i++) {
                let n = r[i],
                    o = n.GetParent();
                o !== null && (o.RemoveChildNode(n), o.IsEmpty() && r.push(o));
            }
        }
        GetDefaultMaterialIndex(e) {
            if (this.defaultMaterialIndex === null) {
                let t = this.params.getDefaultMaterialColor(),
                    r = new q();
                (r.color = t),
                    (r.isDefault = !0),
                    (this.defaultMaterialIndex = e.AddMaterial(r));
            }
            return this.defaultMaterialIndex;
        }
        Reset() {
            this.defaultMaterialIndex = null;
        }
    };
    function ii(s, e) {
        new Di(e).Finalize(s);
    }
    function dn(s) {
        function e(n) {
            return n != null;
        }
        function t(n) {
            return !(!e(n) || isNaN(n));
        }
        function r(n, o) {
            return !(!t(n) || n < 0 || n >= o);
        }
        function i(n, o) {
            function l(a, u, h) {
                return !(
                    !r(h.v0, u.VertexCount()) ||
                    !r(h.v1, u.VertexCount()) ||
                    !r(h.v2, u.VertexCount()) ||
                    (h.HasVertexColors() &&
                        (!r(h.c0, u.VertexColorCount()) ||
                            !r(h.c1, u.VertexColorCount()) ||
                            !r(h.c2, u.VertexColorCount()))) ||
                    !r(h.n0, u.NormalCount()) ||
                    !r(h.n1, u.NormalCount()) ||
                    !r(h.n2, u.NormalCount()) ||
                    (h.HasTextureUVs() &&
                        (!r(h.u0, u.TextureUVCount()) ||
                            !r(h.u1, u.TextureUVCount()) ||
                            !r(h.u2, u.TextureUVCount()))) ||
                    !r(h.mat, a.MaterialCount()) ||
                    !t(h.curve)
                );
            }
            for (let a = 0; a < o.VertexCount(); a++) {
                let u = o.GetVertex(a);
                if (!t(u.x) || !t(u.y) || !t(u.z)) return !1;
            }
            for (let a = 0; a < o.VertexColorCount(); a++) {
                let u = o.GetVertexColor(a);
                if (!t(u.r) || !t(u.g) || !t(u.b)) return !1;
            }
            for (let a = 0; a < o.NormalCount(); a++) {
                let u = o.GetNormal(a);
                if (!t(u.x) || !t(u.y) || !t(u.z)) return !1;
            }
            for (let a = 0; a < o.TextureUVCount(); a++) {
                let u = o.GetTextureUV(a);
                if (!t(u.x) || !t(u.y)) return !1;
            }
            for (let a = 0; a < o.TriangleCount(); a++) {
                let u = o.GetTriangle(a);
                if (!l(n, o, u)) return !1;
            }
            return !0;
        }
        for (let n = 0; n < s.MeshCount(); n++) {
            let o = s.GetMesh(n);
            if (!i(s, o)) return !1;
        }
        return !0;
    }
    var mt = class {
            constructor(e, t) {
                (this.min = e), (this.max = t);
            }
            GetMin() {
                return this.min;
            }
            GetMax() {
                return this.max;
            }
            GetCenter() {
                return new y(
                    (this.min.x + this.max.x) / 2,
                    (this.min.y + this.max.y) / 2,
                    (this.min.z + this.max.z) / 2
                );
            }
        },
        Nt = class {
            constructor() {
                (this.box = new mt(
                    new y(1 / 0, 1 / 0, 1 / 0),
                    new y(-1 / 0, -1 / 0, -1 / 0)
                )),
                    (this.isValid = !1);
            }
            GetBox() {
                return this.isValid ? this.box : null;
            }
            AddPoint(e) {
                (this.box.min.x = Math.min(this.box.min.x, e.x)),
                    (this.box.min.y = Math.min(this.box.min.y, e.y)),
                    (this.box.min.z = Math.min(this.box.min.z, e.z)),
                    (this.box.max.x = Math.max(this.box.max.x, e.x)),
                    (this.box.max.y = Math.max(this.box.max.y, e.y)),
                    (this.box.max.z = Math.max(this.box.max.z, e.z)),
                    (this.isValid = !0);
            }
        };
    var ct = class {
            constructor(e, t) {
                (this.boundingBox = e),
                    (this.level = t),
                    (this.pointItems = []),
                    (this.childNodes = []);
            }
            AddPoint(e, t, r) {
                let i = this.FindNodeForPoint(e);
                if (i === null || i.FindPointDirectly(e) !== null) return !1;
                if (
                    i.pointItems.length < r.maxPointsPerNode ||
                    i.level >= r.maxTreeDepth
                )
                    return i.AddPointDirectly(e, t), !0;
                {
                    i.CreateChildNodes();
                    let n = i.pointItems;
                    i.pointItems = [];
                    for (let o = 0; o < n.length; o++) {
                        let l = n[o];
                        if (!i.AddPoint(l.point, l.data, r)) return !1;
                    }
                    return i.AddPoint(e, t, r);
                }
            }
            FindPoint(e) {
                let t = this.FindNodeForPoint(e);
                return t === null ? null : t.FindPointDirectly(e);
            }
            AddPointDirectly(e, t) {
                this.pointItems.push({ point: e, data: t });
            }
            FindPointDirectly(e) {
                for (let t = 0; t < this.pointItems.length; t++) {
                    let r = this.pointItems[t];
                    if (ye(e, r.point)) return r.data;
                }
                return null;
            }
            FindNodeForPoint(e) {
                if (!this.IsPointInBounds(e)) return null;
                if (this.childNodes.length === 0) return this;
                for (let t = 0; t < this.childNodes.length; t++) {
                    let i = this.childNodes[t].FindNodeForPoint(e);
                    if (i !== null) return i;
                }
                return null;
            }
            CreateChildNodes() {
                function e(l, a, u, h, f, d, c) {
                    let p = new mt(new y(a, u, h), new y(a + f, u + d, h + c));
                    l.childNodes.push(new ct(p, l.level + 1));
                }
                let t = this.boundingBox.min,
                    r = this.boundingBox.GetCenter(),
                    i = (this.boundingBox.max.x - this.boundingBox.min.x) / 2,
                    n = (this.boundingBox.max.y - this.boundingBox.min.y) / 2,
                    o = (this.boundingBox.max.z - this.boundingBox.min.z) / 2;
                e(this, t.x, t.y, t.z, i, n, o),
                    e(this, r.x, t.y, t.z, i, n, o),
                    e(this, t.x, r.y, t.z, i, n, o),
                    e(this, r.x, r.y, t.z, i, n, o),
                    e(this, t.x, t.y, r.z, i, n, o),
                    e(this, r.x, t.y, r.z, i, n, o),
                    e(this, t.x, r.y, r.z, i, n, o),
                    e(this, r.x, r.y, r.z, i, n, o);
            }
            IsPointInBounds(e) {
                return (
                    St(e.x, this.boundingBox.min.x) &&
                    St(e.y, this.boundingBox.min.y) &&
                    St(e.z, this.boundingBox.min.z) &&
                    bt(e.x, this.boundingBox.max.x) &&
                    bt(e.y, this.boundingBox.max.y) &&
                    bt(e.z, this.boundingBox.max.z)
                );
            }
        },
        Dt = class {
            constructor(e, t) {
                (this.options = { maxPointsPerNode: 10, maxTreeDepth: 10 }),
                    t !== void 0 &&
                        (t.maxPointsPerNode !== void 0 &&
                            (this.options.maxPointsPerNode =
                                t.maxPointsPerNode),
                        t.maxTreeDepth !== void 0 &&
                            (this.options.maxTreeDepth = t.maxTreeDepth)),
                    (this.rootNode = new ct(e, 0));
            }
            AddPoint(e, t) {
                return this.rootNode.AddPoint(e, t, this.options);
            }
            FindPoint(e) {
                return this.rootNode.FindPoint(e);
            }
        };
    var br = class {
            constructor() {
                (this.edges = []), (this.triangles = []);
            }
        },
        Sr = class {
            constructor(e, t) {
                (this.vertex1 = e), (this.vertex2 = t), (this.triangles = []);
            }
        },
        wr = class {
            constructor(e, t) {
                (this.edge = e), (this.reversed = t);
            }
        },
        vr = class {
            constructor() {
                (this.triEdge1 = null),
                    (this.triEdge2 = null),
                    (this.triEdge3 = null);
            }
        },
        Pt = class {
            constructor() {
                (this.vertices = []),
                    (this.edges = []),
                    (this.triangleEdges = []),
                    (this.triangles = []),
                    (this.edgeStartToEndVertexMap = new Map());
            }
            AddVertex() {
                return this.vertices.push(new br()), this.vertices.length - 1;
            }
            AddTriangle(e, t, r) {
                function i(u, h, f) {
                    u[h].triangles.push(f);
                }
                function n(u, h, f, d) {
                    let c = u[f],
                        p = h[d];
                    c.edges.push(p.edge);
                }
                function o(u, h, f, d) {
                    let c = h[f];
                    u[c.edge].triangles.push(d);
                }
                let l = this.triangles.length,
                    a = new vr();
                (a.triEdge1 = this.AddTriangleEdge(e, t)),
                    (a.triEdge2 = this.AddTriangleEdge(t, r)),
                    (a.triEdge3 = this.AddTriangleEdge(r, e)),
                    i(this.vertices, e, l),
                    i(this.vertices, t, l),
                    i(this.vertices, r, l),
                    n(this.vertices, this.triangleEdges, e, a.triEdge1),
                    n(this.vertices, this.triangleEdges, t, a.triEdge2),
                    n(this.vertices, this.triangleEdges, r, a.triEdge3),
                    o(this.edges, this.triangleEdges, a.triEdge1, l),
                    o(this.edges, this.triangleEdges, a.triEdge2, l),
                    o(this.edges, this.triangleEdges, a.triEdge3, l),
                    this.triangles.push(a);
            }
            AddTriangleEdge(e, t) {
                let r = e,
                    i = t,
                    n = !1;
                t < e && ((r = t), (i = e), (n = !0));
                let o = this.AddEdge(r, i);
                return (
                    this.triangleEdges.push(new wr(o, n)),
                    this.triangleEdges.length - 1
                );
            }
            AddEdge(e, t) {
                this.edgeStartToEndVertexMap.has(e) ||
                    this.edgeStartToEndVertexMap.set(e, []);
                let r = this.edgeStartToEndVertexMap.get(e);
                for (let n = 0; n < r.length; n++) {
                    let o = r[n];
                    if (o.endVertex === t) return o.edgeIndex;
                }
                let i = this.edges.length;
                return (
                    r.push({ endVertex: t, edgeIndex: i }),
                    this.edges.push(new Sr(e, t)),
                    i
                );
            }
        };
    function Vt(s) {
        let e = !0;
        return (
            s.EnumerateMeshInstances((t) => {
                et(t) !== Le.Empty && (e = !1);
            }),
            e
        );
    }
    function Pi(s) {
        let e = new Nt();
        return (
            s.EnumerateVertices((t) => {
                e.AddPoint(t);
            }),
            e.GetBox()
        );
    }
    function Vi(s) {
        function e(n, o, l) {
            let a = o.FindPoint(n);
            return a === null && ((a = l.AddVertex()), o.AddPoint(n, a)), a;
        }
        let t = Pi(s),
            r = new Dt(t),
            i = new Pt();
        return (
            s.EnumerateTriangleVertices((n, o, l) => {
                let a = e(n, r, i),
                    u = e(o, r, i),
                    h = e(l, r, i);
                i.AddTriangle(a, u, h);
            }),
            i
        );
    }
    function mn(s) {
        function e(r, i, n) {
            let o = r.triangles[i],
                l = r.triangleEdges[o.triEdge1],
                a = r.triangleEdges[o.triEdge2],
                u = r.triangleEdges[o.triEdge3];
            return l.edge === n
                ? l.reversed
                : a.edge === n
                ? a.reversed
                : u.edge === n
                ? u.reversed
                : null;
        }
        let t = Vi(s);
        for (let r = 0; r < t.edges.length; r++) {
            let i = t.edges[r],
                n = i.triangles.length;
            if (n === 0 || n % 2 !== 0) return !1;
            let o = 0;
            for (let l = 0; l < i.triangles.length; l++) {
                let a = i.triangles[l];
                e(t, a, r) ? (o += 1) : (o -= 1);
            }
            if (o !== 0) return !1;
        }
        return !0;
    }
    function cn(s) {
        for (let e = 0; e < s.MaterialCount(); e++) {
            let t = s.GetMaterial(e);
            if (t.isDefault && !t.vertexColors) return !0;
        }
        return !1;
    }
    function pn(s, e) {
        for (let t = 0; t < s.MaterialCount(); t++) {
            let r = s.GetMaterial(t);
            r.isDefault && (r.color = e);
        }
    }
    var _ = class {
        constructor() {
            (this.name = null),
                (this.extension = null),
                (this.callbacks = null),
                (this.model = null),
                (this.error = null),
                (this.message = null);
        }
        Import(e, t, r, i) {
            this.Clear(),
                (this.name = e),
                (this.extension = t),
                (this.callbacks = i),
                (this.model = new At()),
                (this.error = !1),
                (this.message = null),
                this.ResetContent(),
                this.ImportContent(r, () => {
                    this.CreateResult(i);
                });
        }
        Clear() {
            (this.name = null),
                (this.extension = null),
                (this.callbacks = null),
                (this.model = null),
                (this.error = null),
                (this.message = null),
                this.ClearContent();
        }
        CreateResult(e) {
            if (this.error) {
                e.onError(), e.onComplete();
                return;
            }
            if (Vt(this.model)) {
                this.SetError("The model doesn't contain any meshes."),
                    e.onError(),
                    e.onComplete();
                return;
            }
            ii(this.model, {
                getDefaultMaterialColor: this.callbacks.getDefaultMaterialColor,
            }),
                e.onSuccess(),
                e.onComplete();
        }
        CanImportExtension(e) {
            return !1;
        }
        GetUpDirection() {
            return w.Z;
        }
        ClearContent() {}
        ResetContent() {}
        ImportContent(e, t) {}
        GetModel() {
            return this.model;
        }
        SetError(e) {
            (this.error = !0), e != null && (this.message = e);
        }
        WasError() {
            return this.error;
        }
        GetErrorMessage() {
            return this.message;
        }
    };
    function He(s, e, t) {
        let r = s.substring(e),
            i = r.indexOf(t);
        return i !== -1 && (r = r.substring(0, i)), r.trim();
    }
    function Ne(s, e) {
        if (e !== null) {
            let t = s.indexOf(e);
            t !== -1 && (s = s.substring(0, t).trim());
        }
        return s.split(/\s+/u);
    }
    function ve(s, e) {
        function t(n, o) {
            let l = n.trim();
            l.length > 0 && o(l);
        }
        let r = 0,
            i = s.indexOf(
                `
`,
                r
            );
        for (; i !== -1; )
            t(s.substring(r, i), e),
                (r = i + 1),
                (i = s.indexOf(
                    `
`,
                    r
                ));
        t(s.substring(r), e);
    }
    function Oi(s) {
        return (s & (s - 1)) === 0;
    }
    function xn(s) {
        if (Oi(s)) return s;
        let e = Math.pow(2, Math.ceil(Math.log(s) / Math.log(2)));
        return parseInt(e, 10);
    }
    function le(s) {
        (s.transparent = !1), Mt(s.opacity, 1) && (s.transparent = !0);
    }
    var Ot = class {
        constructor(e) {
            (this.createMaterialFunc = e),
                (this.colorToMaterialIndex = new Map());
        }
        GetMaterialIndex(e) {
            let t = ze(e);
            if (this.colorToMaterialIndex.has(t))
                return this.colorToMaterialIndex.get(t);
            {
                let r = this.createMaterialFunc(e);
                return this.colorToMaterialIndex.set(t, r), r;
            }
        }
    };
    var Lt = class extends _ {
        constructor() {
            super();
        }
        CanImportExtension(e) {
            return e === "off";
        }
        GetUpDirection() {
            return w.Y;
        }
        ClearContent() {
            (this.mesh = null), (this.status = null);
        }
        ResetContent() {
            (this.mesh = new k()),
                this.model.AddMeshToRootNode(this.mesh),
                (this.status = {
                    vertexCount: 0,
                    faceCount: 0,
                    foundVertex: 0,
                    foundFace: 0,
                });
        }
        ImportContent(e, t) {
            let r = K(e);
            ve(r, (i) => {
                this.WasError() || this.ProcessLine(i);
            }),
                t();
        }
        ProcessLine(e) {
            if (e[0] === "#") return;
            let t = Ne(e, "#");
            if (t.length !== 0 && t[0] !== "OFF") {
                if (
                    this.status.vertexCount === 0 &&
                    this.status.faceCount === 0
                ) {
                    t.length > 1 &&
                        ((this.status.vertexCount = parseInt(t[0], 10)),
                        (this.status.faceCount = parseInt(t[1], 10)));
                    return;
                }
                if (this.status.foundVertex < this.status.vertexCount) {
                    t.length >= 3 &&
                        (this.mesh.AddVertex(
                            new y(
                                parseFloat(t[0]),
                                parseFloat(t[1]),
                                parseFloat(t[2])
                            )
                        ),
                        (this.status.foundVertex += 1));
                    return;
                }
                if (this.status.foundFace < this.status.faceCount) {
                    if (t.length >= 4) {
                        let r = parseInt(t[0], 10);
                        if (t.length < r + 1) return;
                        for (let i = 0; i < r - 2; i++) {
                            let n = parseInt(t[1]),
                                o = parseInt(t[i + 2]),
                                l = parseInt(t[i + 3]),
                                a = new z(n, o, l);
                            this.mesh.AddTriangle(a);
                        }
                        this.status.foundFace += 1;
                    }
                    return;
                }
            }
        }
    };
    var Bt = class {
        constructor() {
            (this.count = null), (this.current = null), (this.callbacks = null);
        }
        Run(e, t) {
            (this.count = e),
                (this.current = 0),
                (this.callbacks = t),
                e === 0 ? this.TaskReady() : this.RunOnce();
        }
        RunBatch(e, t, r) {
            let i = 0;
            e > 0 && (i = parseInt((e - 1) / t, 10) + 1),
                this.Run(i, {
                    runTask: (n, o) => {
                        let l = n * t,
                            a = Math.min((n + 1) * t, e) - 1;
                        r.runTask(l, a, o);
                    },
                    onReady: r.onReady,
                });
        }
        RunOnce() {
            setTimeout(() => {
                this.callbacks.runTask(this.current, this.TaskReady.bind(this));
            }, 0);
        }
        TaskReady() {
            (this.current += 1),
                this.current < this.count
                    ? this.RunOnce()
                    : this.callbacks.onReady && this.callbacks.onReady();
        }
    };
    function Ar(s) {
        setTimeout(() => {
            s();
        }, 0);
    }
    function ni(s, e) {
        new Bt().Run(s, e);
    }
    function oi(s, e, t) {
        new Bt().RunBatch(s, e, t);
    }
    function si(s) {
        function e(t) {
            t() &&
                setTimeout(() => {
                    e(t);
                }, 1);
        }
        e(s);
    }
    var $ = { Url: 1, File: 2, Decompressed: 3 },
        B = { Text: 1, Binary: 2 };
    function ee(s) {
        let e = s.lastIndexOf("/");
        e === -1 && (e = s.lastIndexOf("\\"));
        let t = s;
        e !== -1 && (t = s.substring(e + 1));
        let r = t.indexOf("?");
        return r !== -1 && (t = t.substring(0, r)), decodeURI(t);
    }
    function ke(s) {
        let e = ee(s),
            t = e.lastIndexOf(".");
        return t === -1 ? "" : e.substring(t + 1).toLowerCase();
    }
    function li(s, e) {
        return new Promise((t, r) => {
            let i = new XMLHttpRequest();
            if ((i.open("GET", s, !0), e === B.Text)) i.responseType = "text";
            else if (e === B.Binary) i.responseType = "arraybuffer";
            else {
                r();
                return;
            }
            (i.onload = function () {
                i.status === 200 ? t(i.response) : r();
            }),
                (i.onerror = function () {
                    r();
                }),
                i.send(null);
        });
    }
    function ai(s, e) {
        return new Promise((t, r) => {
            let i = new FileReader();
            (i.onloadend = function (n) {
                n.target.readyState === FileReader.DONE && t(n.target.result);
            }),
                (i.onerror = function () {
                    r();
                }),
                e === B.Text
                    ? i.readAsText(s)
                    : e === B.Binary
                    ? i.readAsArrayBuffer(s)
                    : r();
        });
    }
    function ui(s) {
        for (let e = 0; e < s.length; e++) {
            let t = s[e];
            if (t.search(/www\.dropbox\.com/u) !== -1) {
                t = t.replace("www.dropbox.com", "dl.dropbox.com");
                let r = t.indexOf("?");
                r !== -1 && (t = t.substring(0, r)), (s[e] = t);
            } else if (t.search(/github\.com/u) !== -1) {
                (t = t.replace("github.com", "raw.githubusercontent.com")),
                    (t = t.replace("/blob", ""));
                let r = t.indexOf("?");
                r !== -1 && (t = t.substring(0, r)), (s[e] = t);
            }
        }
    }
    function gn(s) {
        let e = /^https?:\/\/\S+$/g;
        return s.match(e) !== null;
    }
    var pt = class {
            constructor(e, t) {
                (this.source = t),
                    t === $.Url
                        ? ((this.fileUrl = e),
                          (this.filesObject = null),
                          (this.name = ee(e)),
                          (this.extension = ke(e)))
                        : t === $.File
                        ? ((this.fileUrl = null),
                          (this.filesObject = e),
                          (this.name = ee(e.name)),
                          (this.extension = ke(e.name)))
                        : t === $.Decompressed &&
                          ((this.fileUrl = null),
                          (this.filesObject = null),
                          (this.name = ee(e)),
                          (this.extension = ke(e))),
                    (this.content = null);
            }
            SetContent(e) {
                this.content = e;
            }
        },
        xt = class {
            constructor() {
                this.files = [];
            }
            FillFromFileUrls(e) {
                this.Fill(e, $.Url);
            }
            FillFromfilesObjects(e) {
                this.Fill(e, $.File);
            }
            ExtendFromFileList(e) {
                for (let t = 0; t < e.length; t++) {
                    let r = e[t];
                    this.ContainsFileByPath(r.name) || this.files.push(r);
                }
            }
            GetFiles() {
                return this.files;
            }
            GetContent(e) {
                ni(this.files.length, {
                    runTask: (t, r) => {
                        this.GetFileContent(this.files[t], r);
                    },
                    onReady: e,
                });
            }
            ContainsFileByPath(e) {
                return this.FindFileByPath(e) !== null;
            }
            FindFileByPath(e) {
                let t = ee(e).toLowerCase();
                for (let r = 0; r < this.files.length; r++) {
                    let i = this.files[r];
                    if (i.name.toLowerCase() === t) return i;
                }
                return null;
            }
            IsOnlyUrlSource() {
                if (this.files.length === 0) return !1;
                for (let e = 0; e < this.files.length; e++) {
                    let t = this.files[e];
                    if (t.source !== $.Url && t.source !== $.Decompressed)
                        return !1;
                }
                return !0;
            }
            Fill(e, t) {
                this.files = [];
                for (let r = 0; r < e.length; r++) {
                    let i = e[r],
                        n = new pt(i, t);
                    this.AddFile(n);
                }
            }
            AddFile(e) {
                this.files.push(e);
            }
            GetFileContent(e, t) {
                if (e.content !== null) {
                    t();
                    return;
                }
                let r = null;
                if (e.source === $.Url) r = li(e.fileUrl, B.Binary);
                else if (e.source === $.File) r = ai(e.filesObject, B.Binary);
                else {
                    t();
                    return;
                }
                r.then((i) => {
                    e.SetContent(i);
                })
                    .catch(() => {})
                    .finally(() => {
                        t();
                    });
            }
        };
    var hi = null,
        Cn = new Set();
    function Tn(s) {
        hi = s;
    }
    function Gr(s) {
        return hi === null ? null : hi + "/" + s;
    }
    function pe(s) {
        return new Promise((e, t) => {
            if (hi === null) {
                t();
                return;
            }
            if (Cn.has(s)) {
                e();
                return;
            }
            let r = document.createElement("script");
            (r.type = "text/javascript"),
                (r.src = Gr(s)),
                (r.onload = () => {
                    Cn.add(s), e();
                }),
                (r.onerror = () => {
                    t();
                }),
                document.head.appendChild(r);
        });
    }
    var X = {
            Text: 1,
            Integer: 2,
            Number: 3,
            Boolean: 4,
            Percent: 5,
            Color: 6,
        },
        J = class {
            constructor(e, t, r) {
                (this.type = e), (this.name = t), (this.value = r);
            }
            Clone() {
                return this.type === X.Color
                    ? new J(this.type, this.name, this.value.Clone())
                    : new J(this.type, this.name, this.value);
            }
        },
        ae = class {
            constructor(e) {
                (this.name = e), (this.properties = []);
            }
            PropertyCount() {
                return this.properties.length;
            }
            AddProperty(e) {
                this.properties.push(e);
            }
            GetProperty(e) {
                return this.properties[e];
            }
            Clone() {
                let e = new ae(this.name);
                for (let t of this.properties) e.AddProperty(t.Clone());
                return e;
            }
        };
    function fi(s) {
        return s.type === X.Text
            ? s.value
            : s.type === X.Integer
            ? s.value.toLocaleString()
            : s.type === X.Number
            ? s.value.toLocaleString(void 0, {
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2,
              })
            : s.type === X.Boolean
            ? s.value
                ? "True"
                : "False"
            : s.type === X.Percent
            ? parseInt(s.value * 100, 10).toString() + "%"
            : s.type === X.Color
            ? "#" + ze(s.value)
            : null;
    }
    function di() {
        let s = document.createElement("canvas");
        document.body.appendChild(s);
        let e = { canvas: s, antialias: !0 },
            t = new THREE.WebGLRenderer(e);
        t.setClearColor("#ffffff", 1), t.setSize(10, 10);
        let r = new THREE.Scene(),
            i = new THREE.AmbientLight(8947848);
        r.add(i);
        let n = new THREE.DirectionalLight(8947848);
        n.position.set(0, 0, 1), r.add(n);
        let o = new THREE.PerspectiveCamera(45, 1, 0.1, 1e3);
        o.position.set(0, 0, 1),
            o.up.set(0, 1, 0),
            o.lookAt(new THREE.Vector3(0, 0, 0)),
            r.add(o);
        let l = new THREE.PlaneGeometry(1, 1),
            a = new THREE.Mesh(
                l,
                new THREE.MeshPhongMaterial({ color: 13369344 })
            );
        r.add(a), t.render(r, o);
        let u = t.getContext(),
            h = new Uint8Array(4);
        u.readPixels(5, 5, 1, 1, u.RGBA, u.UNSIGNED_BYTE, h),
            document.body.removeChild(s);
        let f = 50;
        return h[0] < f && h[1] < f && h[2] < f;
    }
    var fe = { Phong: 1, Physical: 2 };
    function mi(s) {
        let e = 0,
            t = 0;
        for (let r = 0; r < s.MaterialCount(); r++) {
            let i = s.GetMaterial(r);
            i.type === se.Phong ? (e += 1) : i.type === se.Physical && (t += 1);
        }
        return e >= t ? fe.Phong : fe.Physical;
    }
    function Ut(s) {
        return be(s.r, s.g, s.b);
    }
    function xe(s) {
        return new THREE.Color(s.r / 255, s.g / 255, s.b / 255);
    }
    function Je(s, e) {
        let t = new k(),
            r = s.attributes.position.array,
            i = s.attributes.position.itemSize || 3;
        for (let u = 0; u < r.length; u += i) {
            let h = r[u],
                f = r[u + 1],
                d = r[u + 2];
            t.AddVertex(new y(h, f, d));
        }
        let n = s.attributes.color !== void 0;
        if (n) {
            let u = s.attributes.color.array,
                h = s.attributes.color.itemSize || 3;
            for (let f = 0; f < u.length; f += h) {
                let d = new THREE.Color(u[f], u[f + 1], u[f + 2]);
                t.AddVertexColor(Ut(d));
            }
        }
        let o = s.attributes.normal !== void 0;
        if (o) {
            let u = s.attributes.normal.array,
                h = s.attributes.normal.itemSize || 3;
            for (let f = 0; f < u.length; f += h) {
                let d = u[f],
                    c = u[f + 1],
                    p = u[f + 2];
                t.AddNormal(new y(d, c, p));
            }
        }
        let l = s.attributes.uv !== void 0;
        if (l) {
            let u = s.attributes.uv.array,
                h = s.attributes.uv.itemSize || 2;
            for (let f = 0; f < u.length; f += h) {
                let d = u[f],
                    c = u[f + 1];
                t.AddTextureUV(new F(d, c));
            }
        }
        let a = null;
        if (s.index !== null) a = s.index.array;
        else {
            a = [];
            for (let u = 0; u < r.length / 3; u++) a.push(u);
        }
        for (let u = 0; u < a.length; u += 3) {
            let h = a[u],
                f = a[u + 1],
                d = a[u + 2],
                c = new z(h, f, d);
            n && c.SetVertexColors(h, f, d),
                o && c.SetNormals(h, f, d),
                l && c.SetTextureUVs(h, f, d),
                e !== null && c.SetMaterial(e),
                t.AddTriangle(c);
        }
        return t;
    }
    var zt = class extends _ {
        constructor() {
            super(), (this.rhino = null);
        }
        CanImportExtension(e) {
            return e === "3dm";
        }
        GetUpDirection() {
            return w.Z;
        }
        ClearContent() {
            (this.instanceIdToObject = null),
                (this.instanceIdToDefinition = null);
        }
        ResetContent() {
            (this.instanceIdToObject = new Map()),
                (this.instanceIdToDefinition = new Map());
        }
        ImportContent(e, t) {
            this.rhino === null
                ? pe("loaders/rhino3dm.min.js")
                      .then(() => {
                          rhino3dm().then((r) => {
                              (this.rhino = r), this.ImportRhinoContent(e), t();
                          });
                      })
                      .catch(() => {
                          this.SetError("Failed to load rhino3dm."), t();
                      })
                : (this.ImportRhinoContent(e), t());
        }
        ImportRhinoContent(e) {
            let t = this.rhino.File3dm.fromByteArray(e);
            if (t === null) {
                this.SetError("Failed to read Rhino file.");
                return;
            }
            this.ImportRhinoDocument(t),
                Vt(this.model) &&
                    this.SetError(
                        "The model doesn't contain any 3D meshes. Try to save the model while you are in shaded view in Rhino."
                    );
        }
        ImportRhinoDocument(e) {
            this.InitRhinoInstances(e),
                this.ImportRhinoUserStrings(e),
                this.ImportRhinoGeometry(e);
        }
        InitRhinoInstances(e) {
            let t = e.objects();
            for (let i = 0; i < t.count; i++) {
                let n = t.get(i),
                    o = n.attributes();
                o.isInstanceDefinitionObject &&
                    this.instanceIdToObject.set(o.id, n);
            }
            let r = e.instanceDefinitions();
            for (let i = 0; i < r.count(); i++) {
                let n = r.get(i);
                this.instanceIdToDefinition.set(n.id, n);
            }
        }
        ImportRhinoUserStrings(e) {
            let t = e.strings();
            if (t.count() > 0) {
                let r = new ae("Document user texts");
                for (let i = 0; i < t.count(); i++) {
                    let n = t.get(i);
                    r.AddProperty(new J(X.Text, n[0], n[1]));
                }
                this.model.AddPropertyGroup(r);
            }
        }
        ImportRhinoGeometry(e) {
            let t = e.objects();
            for (let r = 0; r < t.count; r++) {
                let i = t.get(r);
                this.ImportRhinoGeometryObject(e, i, []);
            }
        }
        ImportRhinoGeometryObject(e, t, r) {
            let i = t.geometry(),
                n = t.attributes(),
                o = i.objectType;
            if (n.isInstanceDefinitionObject && r.length === 0) return;
            let l = null,
                a = !1;
            if (o === this.rhino.ObjectType.Mesh) (l = i), (a = !1);
            else if (o === this.rhino.ObjectType.Extrusion)
                (l = i.getMesh(this.rhino.MeshType.Any)), (a = !0);
            else if (o === this.rhino.ObjectType.Brep) {
                l = new this.rhino.Mesh();
                let u = i.faces();
                for (let h = 0; h < u.count; h++) {
                    let f = u.get(h),
                        d = f.getMesh(this.rhino.MeshType.Any);
                    d && (l.append(d), d.delete()), f.delete();
                }
                u.delete(), l.compact(), (a = !0);
            } else if (o === this.rhino.ObjectType.SubD)
                i.subdivide(3),
                    (l = this.rhino.Mesh.createFromSubDControlNet(i)),
                    (a = !0);
            else if (o === this.rhino.ObjectType.InstanceReference) {
                let u = i.parentIdefId;
                if (this.instanceIdToDefinition.has(u)) {
                    let f = this.instanceIdToDefinition.get(u).getObjectIds();
                    for (let d = 0; d < f.length; d++) {
                        let c = f[d];
                        if (this.instanceIdToObject.has(c)) {
                            let p = this.instanceIdToObject.get(c);
                            r.push(t),
                                this.ImportRhinoGeometryObject(e, p, r),
                                r.pop();
                        }
                    }
                }
            }
            l !== null && (this.ImportRhinoMesh(e, l, t, r), a && l.delete());
        }
        ImportRhinoMesh(e, t, r, i) {
            let n = r.attributes(),
                o = this.GetMaterialIndex(e, r, i),
                l = t.toThreejsJSON(),
                a = Je(l.data, o);
            a.SetName(n.name);
            let u = n.getUserStrings();
            if (u.length > 0) {
                let h = new ae("User texts");
                for (let f = 0; f < u.length; f++) {
                    let d = u[f];
                    h.AddProperty(new J(X.Text, d[0], d[1]));
                }
                a.AddPropertyGroup(h);
            }
            if (i.length !== 0) {
                let h = new L().CreateIdentity();
                for (let d = i.length - 1; d >= 0; d--) {
                    let m = i[d].geometry().xform.toFloatArray(!1),
                        x = new L(m);
                    h = h.MultiplyMatrix(x);
                }
                let f = new H(h);
                Be(a, f);
            }
            this.model.AddMeshToRootNode(a);
        }
        GetMaterialIndex(e, t, r) {
            function i(a, u, h) {
                let f = u.attributes();
                if (
                    f.materialSource ===
                    a.ObjectMaterialSource.MaterialFromObject
                ) {
                    let d = f.materialIndex;
                    if (d > -1) return e.materials().get(d);
                } else if (
                    f.materialSource ===
                    a.ObjectMaterialSource.MaterialFromLayer
                ) {
                    let d = f.layerIndex;
                    if (d > -1) {
                        let p = e.layers().get(d).renderMaterialIndex;
                        if (p > -1) return e.materials().get(p);
                    }
                } else if (
                    f.materialSource ===
                        a.ObjectMaterialSource.MaterialFromParent &&
                    h.length !== 0
                )
                    return i(a, h[0], []);
                return null;
            }
            function n(a, u) {
                function h(x, g) {
                    x.Set(g.r, g.g, g.b);
                }
                function f(x) {
                    return x.r === 0 && x.g === 0 && x.b === 0;
                }
                function d(x) {
                    return x.r === 255 && x.g === 255 && x.b === 255;
                }
                let c = null,
                    p = a.physicallyBased();
                p.supported
                    ? ((c = new _e()),
                      (c.metalness = p.metallic ? 1 : 0),
                      (c.roughness = p.roughness))
                    : ((c = new q()),
                      h(c.ambient, a.ambientColor),
                      h(c.specular, a.specularColor)),
                    (c.name = a.name),
                    h(c.color, a.diffuseColor),
                    (c.opacity = 1 - a.transparency),
                    le(c),
                    f(c.color) &&
                        !d(a.reflectionColor) &&
                        h(c.color, a.reflectionColor),
                    f(c.color) &&
                        !d(a.transparentColor) &&
                        h(c.color, a.transparentColor);
                let m = a.getBitmapTexture();
                if (m) {
                    let x = new ce(),
                        g = ee(m.fileName),
                        C = u.getFileBuffer(g);
                    (x.name = g), (x.buffer = C), (c.diffuseMap = x);
                }
                return c;
            }
            function o(a, u, h) {
                let f = n(u, h);
                for (let d = 0; d < a.MaterialCount(); d++)
                    if (a.GetMaterial(d).IsEqual(f)) return d;
                return a.AddMaterial(f);
            }
            let l = i(this.rhino, t, r);
            return l === null ? null : o(this.model, l, this.callbacks);
        }
    };
    var je = class extends _ {
            constructor() {
                super();
            }
            GetExternalLibraries() {
                return null;
            }
            CreateLoader(e) {
                return null;
            }
            GetMainObject(e) {
                return e;
            }
            IsMeshVisible(e) {
                return !0;
            }
            ClearContent() {
                (this.loader = null),
                    (this.materialIdToIndex = null),
                    (this.objectUrlToFileName = null);
            }
            ResetContent() {
                (this.loader = null),
                    (this.materialIdToIndex = new Map()),
                    (this.objectUrlToFileName = new Map());
            }
            ImportContent(e, t) {
                async function r(n, o, l) {
                    try {
                        for (let a = 0; a < n.length; a++) await pe(n[a]);
                    } catch {
                        l();
                    }
                    o();
                }
                let i = this.GetExternalLibraries();
                if (i === null) {
                    t();
                    return;
                }
                r(
                    i,
                    () => {
                        this.LoadModel(e, t);
                    },
                    () => {
                        this.SetError("Failed to load three.js loader."), t();
                    }
                );
            }
            LoadModel(e, t) {
                let r = !1,
                    i = new THREE.LoadingManager(() => {
                        r = !0;
                    }),
                    n = ut(e);
                i.setURLModifier((l) => {
                    if (l === n) return l;
                    let a = ee(l);
                    if (ke(l).length > 0) {
                        let h = this.callbacks.getFileBuffer(l);
                        if (h !== null) {
                            let f = ut(h);
                            return this.objectUrlToFileName.set(f, a), f;
                        }
                    }
                    return l;
                });
                let o = this.CreateLoader(i);
                if (o === null) {
                    t();
                    return;
                }
                o.load(
                    n,
                    (l) => {
                        si(() =>
                            r ? (this.OnThreeObjectsLoaded(l, t), !1) : !0
                        );
                    },
                    () => {},
                    (l) => {
                        this.SetError(l), t();
                    }
                );
            }
            OnThreeObjectsLoaded(e, t) {
                function r(l) {
                    let a = new L().CreateIdentity();
                    return (
                        l.updateMatrix(),
                        l.matrix !== void 0 &&
                            l.matrix !== null &&
                            a.Set(l.matrix.elements),
                        new H(a)
                    );
                }
                function i(l, a, u, h) {
                    let f = new ue();
                    u.name !== void 0 && f.SetName(u.name),
                        f.SetTransformation(r(u)),
                        h.AddChildNode(f);
                    for (let d of u.children) i(l, a, d, f);
                    if (u.isMesh && l.IsMeshVisible(u)) {
                        u.children.length === 0 && f.SetType(Me.MeshNode);
                        let d = l.ConvertThreeMesh(u),
                            c = a.AddMesh(d);
                        f.AddMeshIndex(c);
                    }
                }
                let n = this.GetMainObject(e),
                    o = this.model.GetRootNode();
                o.SetTransformation(r(n));
                for (let l of n.children) i(this, this.model, l, o);
                t();
            }
            ConvertThreeMesh(e) {
                let t = null;
                if (Array.isArray(e.material)) {
                    if (
                        ((t = Je(e.geometry, null)),
                        e.geometry.attributes.color === void 0 ||
                            e.geometry.attributes.color === null)
                    ) {
                        let r = [];
                        for (let i = 0; i < e.material.length; i++) {
                            let n = e.material[i],
                                o = this.FindOrCreateMaterial(n);
                            r.push(o);
                        }
                        for (let i = 0; i < e.geometry.groups.length; i++) {
                            let n = e.geometry.groups[i],
                                o = null;
                            n.count === 1 / 0
                                ? (o = t.TriangleCount())
                                : (o = n.start / 3 + n.count / 3);
                            for (let l = n.start / 3; l < o; l++)
                                t.GetTriangle(l).SetMaterial(
                                    r[n.materialIndex]
                                );
                        }
                    }
                } else {
                    let r = this.FindOrCreateMaterial(e.material);
                    t = Je(e.geometry, r);
                }
                return (
                    e.name !== void 0 && e.name !== null && t.SetName(e.name), t
                );
            }
            FindOrCreateMaterial(e) {
                if (this.materialIdToIndex.has(e.id))
                    return this.materialIdToIndex.get(e.id);
                let t = this.ConvertThreeMaterial(e),
                    r = this.model.AddMaterial(t);
                return this.materialIdToIndex.set(e.id, r), r;
            }
            ConvertThreeMaterial(e) {
                function t(i, n) {
                    function o(l) {
                        if (l.data !== void 0 && l.data !== null) {
                            let a = new ImageData(l.width, l.height),
                                u = l.width * l.height * 4;
                            for (let h = 0; h < u; h++) a.data[h] = l.data[h];
                            return THREE.ImageUtils.getDataURL(a);
                        } else return THREE.ImageUtils.getDataURL(l);
                    }
                    if (i == null || i.image === void 0 || i.image === null)
                        return null;
                    try {
                        let l = o(i.image),
                            a = at(l),
                            u = new ce(),
                            h = null;
                        return (
                            n.has(i.image.src)
                                ? (h = n.get(i.image.src))
                                : i.name !== void 0 && i.name !== null
                                ? (h = i.name + "." + Qe(a.mimeType))
                                : (h =
                                      "Embedded_" +
                                      i.id.toString() +
                                      "." +
                                      Qe(a.mimeType)),
                            (u.name = h),
                            (u.mimeType = a.mimeType),
                            (u.buffer = a.buffer),
                            (u.rotation = i.rotation),
                            (u.offset.x = i.offset.x),
                            (u.offset.y = i.offset.y),
                            (u.scale.x = i.repeat.x),
                            (u.scale.y = i.repeat.y),
                            u
                        );
                    } catch {
                        return null;
                    }
                }
                let r = new q();
                return (
                    (r.name = e.name),
                    (r.color = Ut(e.color)),
                    (r.opacity = e.opacity),
                    (r.transparent = e.transparent),
                    (r.alphaTest = e.alphaTest),
                    e.type === "MeshPhongMaterial" &&
                        ((r.specular = Ut(e.specular)),
                        (r.shininess = e.shininess / 100)),
                    (r.diffuseMap = t(e.map, this.objectUrlToFileName)),
                    (r.normalMap = t(e.normalMap, this.objectUrlToFileName)),
                    (r.bumpMap = t(e.bumpMap, this.objectUrlToFileName)),
                    r
                );
            }
        },
        _t = class extends je {
            constructor() {
                super();
            }
            CanImportExtension(e) {
                return e === "fbx";
            }
            GetUpDirection() {
                return w.Y;
            }
            GetExternalLibraries() {
                return [
                    "loaders/fflate.min.js",
                    "three_loaders/TGALoader.js",
                    "three_loaders/FBXLoader.js",
                ];
            }
            CreateLoader(e) {
                return (
                    e.addHandler(/\.tga$/i, new THREE.TGALoader(e)),
                    new THREE.FBXLoader(e)
                );
            }
            GetMainObject(e) {
                return e;
            }
        },
        Ht = class extends je {
            constructor() {
                super();
            }
            CanImportExtension(e) {
                return e === "dae";
            }
            GetUpDirection() {
                return w.Y;
            }
            GetExternalLibraries() {
                return [
                    "three_loaders/TGALoader.js",
                    "three_loaders/ColladaLoader.js",
                ];
            }
            CreateLoader(e) {
                return (
                    e.addHandler(/\.tga$/i, new THREE.TGALoader(e)),
                    new THREE.ColladaLoader(e)
                );
            }
            GetMainObject(e) {
                return e.scene;
            }
        },
        kt = class extends je {
            constructor() {
                super();
            }
            CanImportExtension(e) {
                return e === "wrl";
            }
            GetUpDirection() {
                return w.Y;
            }
            GetExternalLibraries() {
                return [
                    "three_loaders/chevrotain.min.js",
                    "three_loaders/VRMLLoader.js",
                ];
            }
            CreateLoader(e) {
                return new THREE.VRMLLoader(e);
            }
            GetMainObject(e) {
                return e;
            }
            IsMeshVisible(e) {
                let t = !0;
                if (Array.isArray(e.material)) {
                    for (let r = 0; r < e.material.length; r++)
                        if (e.material[r].side === THREE.BackSide) {
                            t = !1;
                            break;
                        }
                } else t = e.material.side !== THREE.BackSide;
                return t;
            }
        },
        jt = class extends je {
            constructor() {
                super();
            }
            CanImportExtension(e) {
                return e === "3mf";
            }
            GetUpDirection() {
                return w.Z;
            }
            GetExternalLibraries() {
                return ["loaders/fflate.min.js", "three_loaders/3MFLoader.js"];
            }
            CreateLoader(e) {
                return new THREE.ThreeMFLoader(e);
            }
            GetMainObject(e) {
                return e;
            }
        };
    var ci = class extends je {
        constructor() {
            super();
        }
        CanImportExtension(e) {
            return e === "svg";
        }
        GetUpDirection() {
            return w.Z;
        }
        GetExternalLibraries() {
            return ["three_loaders/SVGLoader.js"];
        }
        CreateLoader(e) {
            return new THREE.SVGLoader(e);
        }
        GetMainObject(e) {
            function t(o) {
                let l = o.userData.style;
                return !(l.fill === void 0 || l.fill === "none");
            }
            function r(o, l, a) {
                let u = null;
                for (let h of o)
                    if (h.style === l && h.opacity === a) {
                        u = h.material;
                        break;
                    }
                return (
                    u === null &&
                        ((u = new THREE.MeshPhongMaterial({
                            color: new THREE.Color().setStyle(l),
                            opacity: a,
                            transparent: a < 1,
                        })),
                        o.push({ style: l, opacity: a, material: u })),
                    u
                );
            }
            let i = [],
                n = new THREE.Object3D();
            n.rotation.x = Math.PI;
            for (let o of e.paths) {
                let l = THREE.SVGLoader.createShapes(o);
                if (t(o)) {
                    let a = o.userData.style,
                        u = r(i, a.fill, a.opacity);
                    for (let h of l) {
                        let f = new THREE.ExtrudeGeometry(h, {
                                depth: 10,
                                bevelEnabled: !1,
                            }),
                            d = new THREE.Mesh(f, u);
                        (d.name = o.userData.node.id), n.add(d);
                    }
                }
            }
            return n;
        }
    };
    var de = class {
        constructor(e, t) {
            (this.arrayBuffer = e),
                (this.dataView = new DataView(e)),
                (this.isLittleEndian = t),
                (this.position = 0);
        }
        GetPosition() {
            return this.position;
        }
        SetPosition(e) {
            this.position = e;
        }
        GetByteLength() {
            return this.arrayBuffer.byteLength;
        }
        Skip(e) {
            this.position = this.position + e;
        }
        End() {
            return this.position >= this.arrayBuffer.byteLength;
        }
        ReadArrayBuffer(e) {
            let t = new Uint8Array(this.arrayBuffer),
                r = new ArrayBuffer(e),
                i = new Uint8Array(r),
                n = t.subarray(this.position, this.position + e);
            return i.set(n, 0), (this.position += e), r;
        }
        ReadBoolean8() {
            let e = this.dataView.getInt8(this.position);
            return (this.position = this.position + 1), !!e;
        }
        ReadCharacter8() {
            let e = this.dataView.getInt8(this.position);
            return (this.position = this.position + 1), e;
        }
        ReadUnsignedCharacter8() {
            let e = this.dataView.getUint8(this.position);
            return (this.position = this.position + 1), e;
        }
        ReadInteger16() {
            let e = this.dataView.getInt16(this.position, this.isLittleEndian);
            return (this.position = this.position + 2), e;
        }
        ReadUnsignedInteger16() {
            let e = this.dataView.getUint16(this.position, this.isLittleEndian);
            return (this.position = this.position + 2), e;
        }
        ReadInteger32() {
            let e = this.dataView.getInt32(this.position, this.isLittleEndian);
            return (this.position = this.position + 4), e;
        }
        ReadUnsignedInteger32() {
            let e = this.dataView.getUint32(this.position, this.isLittleEndian);
            return (this.position = this.position + 4), e;
        }
        ReadFloat32() {
            let e = this.dataView.getFloat32(
                this.position,
                this.isLittleEndian
            );
            return (this.position = this.position + 4), e;
        }
        ReadDouble64() {
            let e = this.dataView.getFloat64(
                this.position,
                this.isLittleEndian
            );
            return (this.position = this.position + 8), e;
        }
    };
    var A = {
            MAIN3DS: 19789,
            EDIT3DS: 15677,
            EDIT_MATERIAL: 45055,
            MAT_NAME: 40960,
            MAT_AMBIENT: 40976,
            MAT_DIFFUSE: 40992,
            MAT_SPECULAR: 41008,
            MAT_SHININESS: 41024,
            MAT_SHININESS_STRENGTH: 41025,
            MAT_TRANSPARENCY: 41040,
            MAT_COLOR_F: 16,
            MAT_COLOR: 17,
            MAT_LIN_COLOR: 18,
            MAT_LIN_COLOR_F: 19,
            MAT_TEXMAP: 41472,
            MAT_TEXMAP_NAME: 41728,
            MAT_TEXMAP_UOFFSET: 41816,
            MAT_TEXMAP_VOFFSET: 41818,
            MAT_TEXMAP_USCALE: 41812,
            MAT_TEXMAP_VSCALE: 41814,
            MAT_TEXMAP_ROTATION: 41820,
            PERCENTAGE: 48,
            PERCENTAGE_F: 49,
            EDIT_OBJECT: 16384,
            OBJ_TRIMESH: 16640,
            OBJ_LIGHT: 17920,
            OBJ_CAMERA: 18176,
            TRI_VERTEX: 16656,
            TRI_TEXVERTEX: 16704,
            TRI_FACE: 16672,
            TRI_TRANSFORMATION: 16736,
            TRI_MATERIAL: 16688,
            TRI_SMOOTH: 16720,
            KF3DS: 45056,
            OBJECT_NODE: 45058,
            OBJECT_HIERARCHY: 45072,
            OBJECT_INSTANCE_NAME: 45073,
            OBJECT_PIVOT: 45075,
            OBJECT_POSITION: 45088,
            OBJECT_ROTATION: 45089,
            OBJECT_SCALE: 45090,
            OBJECT_ID: 45104,
        },
        Li = class {
            constructor() {
                (this.id = -1),
                    (this.name = ""),
                    (this.flags = -1),
                    (this.parentId = -1),
                    (this.instanceName = ""),
                    (this.pivot = [0, 0, 0]),
                    (this.positions = []),
                    (this.rotations = []),
                    (this.scales = []);
            }
        },
        Bi = class {
            constructor() {
                (this.nodes = []), (this.nodeIdToNode = new Map());
            }
            IsEmpty() {
                return this.nodes.length === 0;
            }
            AddNode(e) {
                this.nodes.push(e), this.nodeIdToNode.set(e.nodeId, e);
            }
            GetNodes() {
                return this.nodes;
            }
        },
        Wt = class extends _ {
            constructor() {
                super();
            }
            CanImportExtension(e) {
                return e === "3ds";
            }
            GetUpDirection() {
                return w.Z;
            }
            ClearContent() {
                (this.materialNameToIndex = null),
                    (this.meshNameToIndex = null),
                    (this.nodeList = null);
            }
            ResetContent() {
                (this.materialNameToIndex = new Map()),
                    (this.meshNameToIndex = new Map()),
                    (this.nodeList = new Bi());
            }
            ImportContent(e, t) {
                this.ProcessBinary(e), t();
            }
            ProcessBinary(e) {
                let t = new de(e, !0),
                    r = t.GetByteLength();
                this.ReadChunks(t, r, (i, n) => {
                    i === A.MAIN3DS
                        ? this.ReadMainChunk(t, n)
                        : this.SkipChunk(t, n);
                });
            }
            ReadMainChunk(e, t) {
                let r = this.GetChunkEnd(e, t);
                this.ReadChunks(e, r, (i, n) => {
                    i === A.EDIT3DS
                        ? this.ReadEditorChunk(e, n)
                        : i === A.KF3DS
                        ? this.ReadKeyFrameChunk(e, n)
                        : this.SkipChunk(e, n);
                }),
                    this.BuildNodeHierarchy();
            }
            ReadEditorChunk(e, t) {
                let r = this.GetChunkEnd(e, t);
                this.ReadChunks(e, r, (i, n) => {
                    i === A.EDIT_MATERIAL
                        ? this.ReadMaterialChunk(e, n)
                        : i === A.EDIT_OBJECT
                        ? this.ReadObjectChunk(e, n)
                        : this.SkipChunk(e, n);
                });
            }
            ReadMaterialChunk(e, t) {
                let r = new q(),
                    i = this.GetChunkEnd(e, t),
                    n = null,
                    o = null;
                this.ReadChunks(e, i, (a, u) => {
                    a === A.MAT_NAME
                        ? (r.name = this.ReadName(e))
                        : a === A.MAT_AMBIENT
                        ? (r.ambient = this.ReadColorChunk(e, u))
                        : a === A.MAT_DIFFUSE
                        ? (r.color = this.ReadColorChunk(e, u))
                        : a === A.MAT_SPECULAR
                        ? (r.specular = this.ReadColorChunk(e, u))
                        : a === A.MAT_SHININESS
                        ? (n = this.ReadPercentageChunk(e, u))
                        : a === A.MAT_SHININESS_STRENGTH
                        ? (o = this.ReadPercentageChunk(e, u))
                        : a === A.MAT_TRANSPARENCY
                        ? ((r.opacity = 1 - this.ReadPercentageChunk(e, u)),
                          le(r))
                        : a === A.MAT_TEXMAP
                        ? ((r.diffuseMap = this.ReadTextureMapChunk(e, u)),
                          le(r))
                        : this.SkipChunk(e, u);
                }),
                    n !== null && o !== null && (r.shininess = (n * o) / 10);
                let l = this.model.AddMaterial(r);
                this.materialNameToIndex.set(r.name, l);
            }
            ReadTextureMapChunk(e, t) {
                let r = new ce(),
                    i = this.GetChunkEnd(e, t);
                return (
                    this.ReadChunks(e, i, (n, o) => {
                        if (n === A.MAT_TEXMAP_NAME) {
                            let l = this.ReadName(e),
                                a = this.callbacks.getFileBuffer(l);
                            (r.name = l), (r.buffer = a);
                        } else
                            n === A.MAT_TEXMAP_UOFFSET
                                ? (r.offset.x = e.ReadFloat32())
                                : n === A.MAT_TEXMAP_VOFFSET
                                ? (r.offset.y = e.ReadFloat32())
                                : n === A.MAT_TEXMAP_USCALE
                                ? (r.scale.x = e.ReadFloat32())
                                : n === A.MAT_TEXMAP_VSCALE
                                ? (r.scale.y = e.ReadFloat32())
                                : n === A.MAT_TEXMAP_ROTATION
                                ? (r.rotation = e.ReadFloat32() * Ze)
                                : this.SkipChunk(e, o);
                    }),
                    r
                );
            }
            ReadColorChunk(e, t) {
                let r = new R(0, 0, 0),
                    i = this.GetChunkEnd(e, t),
                    n = !1;
                return (
                    this.ReadChunks(e, i, (o, l) => {
                        o === A.MAT_COLOR
                            ? n ||
                              ((r.r = e.ReadUnsignedCharacter8()),
                              (r.g = e.ReadUnsignedCharacter8()),
                              (r.b = e.ReadUnsignedCharacter8()))
                            : o === A.MAT_LIN_COLOR
                            ? ((r.r = e.ReadUnsignedCharacter8()),
                              (r.g = e.ReadUnsignedCharacter8()),
                              (r.b = e.ReadUnsignedCharacter8()),
                              (n = !0))
                            : o === A.MAT_COLOR_F
                            ? n ||
                              ((r.r = he(e.ReadFloat32())),
                              (r.g = he(e.ReadFloat32())),
                              (r.b = he(e.ReadFloat32())))
                            : o === A.MAT_LIN_COLOR_F
                            ? ((r.r = he(e.ReadFloat32())),
                              (r.g = he(e.ReadFloat32())),
                              (r.b = he(e.ReadFloat32())),
                              (n = !0))
                            : this.SkipChunk(e, l);
                    }),
                    r
                );
            }
            ReadPercentageChunk(e, t) {
                let r = 0,
                    i = this.GetChunkEnd(e, t);
                return (
                    this.ReadChunks(e, i, (n, o) => {
                        n === A.PERCENTAGE
                            ? (r = e.ReadUnsignedInteger16() / 100)
                            : n === A.PERCENTAGE_F
                            ? (r = e.ReadFloat32())
                            : this.SkipChunk(e, o);
                    }),
                    r
                );
            }
            ReadObjectChunk(e, t) {
                let r = this.GetChunkEnd(e, t),
                    i = this.ReadName(e);
                this.ReadChunks(e, r, (n, o) => {
                    n === A.OBJ_TRIMESH
                        ? this.ReadMeshChunk(e, o, i)
                        : this.SkipChunk(e, o);
                });
            }
            ReadMeshChunk(e, t, r) {
                function i(h, f) {
                    if (!f.IsValid()) return;
                    let d = f.Determinant(),
                        c = qe(d);
                    c && (f = new L().CreateScale(-1, 1, 1).MultiplyMatrix(f));
                    let p = f.Invert();
                    if (p === null) return;
                    let m = new H(p);
                    Be(h, m), c && ti(h);
                }
                let n = new k();
                n.SetName(r);
                let o = this.GetChunkEnd(e, t),
                    l = null;
                if (
                    (this.ReadChunks(e, o, (h, f) => {
                        h === A.TRI_VERTEX
                            ? this.ReadVerticesChunk(n, e)
                            : h === A.TRI_TEXVERTEX
                            ? this.ReadTextureVerticesChunk(n, e)
                            : h === A.TRI_FACE
                            ? this.ReadFacesChunk(n, e, f)
                            : h === A.TRI_TRANSFORMATION
                            ? (l = this.ReadTransformationChunk(e))
                            : this.SkipChunk(e, f);
                    }),
                    n.VertexCount() === n.TextureUVCount())
                )
                    for (let h = 0; h < n.TriangleCount(); h++) {
                        let f = n.GetTriangle(h);
                        f.SetTextureUVs(f.v0, f.v1, f.v2);
                    }
                let a = new L(l);
                i(n, a);
                let u = this.model.AddMesh(n);
                this.meshNameToIndex.set(n.GetName(), u);
            }
            ReadVerticesChunk(e, t) {
                let r = t.ReadUnsignedInteger16();
                for (let i = 0; i < r; i++) {
                    let n = t.ReadFloat32(),
                        o = t.ReadFloat32(),
                        l = t.ReadFloat32();
                    e.AddVertex(new y(n, o, l));
                }
            }
            ReadTextureVerticesChunk(e, t) {
                let r = t.ReadUnsignedInteger16();
                for (let i = 0; i < r; i++) {
                    let n = t.ReadFloat32(),
                        o = t.ReadFloat32();
                    e.AddTextureUV(new F(n, o));
                }
            }
            ReadFacesChunk(e, t, r) {
                let i = this.GetChunkEnd(t, r),
                    n = t.ReadUnsignedInteger16();
                for (let o = 0; o < n; o++) {
                    let l = t.ReadUnsignedInteger16(),
                        a = t.ReadUnsignedInteger16(),
                        u = t.ReadUnsignedInteger16();
                    t.ReadUnsignedInteger16(), e.AddTriangle(new z(l, a, u));
                }
                this.ReadChunks(t, i, (o, l) => {
                    o === A.TRI_MATERIAL
                        ? this.ReadFaceMaterialsChunk(e, t)
                        : o === A.TRI_SMOOTH
                        ? this.ReadFaceSmoothingGroupsChunk(e, n, t)
                        : this.SkipChunk(t, l);
                });
            }
            ReadFaceMaterialsChunk(e, t) {
                let r = this.ReadName(t),
                    i = this.materialNameToIndex.get(r),
                    n = t.ReadUnsignedInteger16();
                for (let o = 0; o < n; o++) {
                    let l = t.ReadUnsignedInteger16(),
                        a = e.GetTriangle(l);
                    i !== void 0 && (a.mat = i);
                }
            }
            ReadFaceSmoothingGroupsChunk(e, t, r) {
                for (let i = 0; i < t; i++) {
                    let n = r.ReadUnsignedInteger32(),
                        o = e.GetTriangle(i);
                    o.curve = n;
                }
            }
            ReadTransformationChunk(e) {
                let t = [];
                for (let r = 0; r < 4; r++) {
                    for (let i = 0; i < 3; i++) t.push(e.ReadFloat32());
                    r < 3 ? t.push(0) : t.push(1);
                }
                return t;
            }
            ReadKeyFrameChunk(e, t) {
                let r = this.GetChunkEnd(e, t);
                this.ReadChunks(e, r, (i, n) => {
                    i === A.OBJECT_NODE
                        ? this.ReadObjectNodeChunk(e, n)
                        : this.SkipChunk(e, n);
                });
            }
            BuildNodeHierarchy() {
                function e(r, i) {
                    function n(u) {
                        return u.positions.length === 0
                            ? [0, 0, 0]
                            : u.positions[0];
                    }
                    function o(u) {
                        function h(d) {
                            let c = [0, 0, 0, 1],
                                p = Math.sqrt(
                                    d[0] * d[0] + d[1] * d[1] + d[2] * d[2]
                                );
                            if (p > 0) {
                                let m = d[3] * -0.5,
                                    x = Math.sin(m) / p;
                                c = [x * d[0], x * d[1], x * d[2], Math.cos(m)];
                            }
                            return c;
                        }
                        if (u.rotations.length === 0) return [0, 0, 0, 1];
                        let f = u.rotations[0];
                        return h(f);
                    }
                    function l(u) {
                        return u.scales.length === 0 ? [1, 1, 1] : u.scales[0];
                    }
                    let a = new L();
                    if ((a.ComposeTRS(Re(n(r)), $e(o(r)), Re(l(r))), i)) {
                        let u = r.pivot;
                        a = new L()
                            .CreateTranslation(-u[0], -u[1], -u[2])
                            .MultiplyMatrix(a);
                    }
                    return new H(a);
                }
                let t = this.model.GetRootNode();
                if (this.nodeList.IsEmpty())
                    for (let r = 0; r < this.model.MeshCount(); r++)
                        t.AddMeshIndex(r);
                else {
                    let r = new Map();
                    for (let i of this.nodeList.GetNodes()) {
                        let n = new ue();
                        i.name.length > 0 &&
                            i.name !== "$$$DUMMY" &&
                            (n.SetName(i.name),
                            i.instanceName.length > 0 &&
                                n.SetName(n.GetName() + " " + i.instanceName)),
                            i.parentId === 65535 || !r.has(i.parentId)
                                ? t.AddChildNode(n)
                                : r.get(i.parentId).AddChildNode(n),
                            r.set(i.id, n);
                        let o = this.meshNameToIndex.has(i.name);
                        n.SetTransformation(e(i, o)),
                            o &&
                                (n.SetType(Me.MeshNode),
                                n.AddMeshIndex(
                                    this.meshNameToIndex.get(i.name)
                                ));
                    }
                }
            }
            ReadObjectNodeChunk(e, t) {
                function r(o, l, a) {
                    let u = [];
                    l.Skip(10);
                    let h = l.ReadInteger32();
                    for (let f = 0; f < h; f++) {
                        l.ReadInteger32(),
                            l.ReadUnsignedInteger16() !== 0 && l.ReadFloat32();
                        let c = null;
                        if (a === A.OBJECT_ROTATION) {
                            let p = l.ReadFloat32();
                            (c = o.ReadVector(l)), (c[3] = p);
                        } else c = o.ReadVector(l);
                        u.push(c);
                    }
                    return u;
                }
                let i = new Li(),
                    n = this.GetChunkEnd(e, t);
                this.ReadChunks(e, n, (o, l) => {
                    o === A.OBJECT_HIERARCHY
                        ? ((i.name = this.ReadName(e)),
                          (i.flags = e.ReadUnsignedInteger32()),
                          (i.parentId = e.ReadUnsignedInteger16()))
                        : o === A.OBJECT_INSTANCE_NAME
                        ? (i.instanceName = this.ReadName(e))
                        : o === A.OBJECT_PIVOT
                        ? (i.pivot = this.ReadVector(e))
                        : o === A.OBJECT_POSITION
                        ? (i.positions = r(this, e, A.OBJECT_POSITION))
                        : o === A.OBJECT_ROTATION
                        ? (i.rotations = r(this, e, A.OBJECT_ROTATION))
                        : o === A.OBJECT_SCALE
                        ? (i.scales = r(this, e, A.OBJECT_SCALE))
                        : o === A.OBJECT_ID
                        ? (i.id = e.ReadUnsignedInteger16())
                        : this.SkipChunk(e, l);
                }),
                    this.nodeList.AddNode(i);
            }
            ReadName(e) {
                let t = "",
                    r = 0,
                    i = 0;
                for (; i < 64 && ((r = e.ReadCharacter8()), r !== 0); )
                    (t = t + String.fromCharCode(r)), (i = i + 1);
                return t;
            }
            ReadVector(e) {
                return [e.ReadFloat32(), e.ReadFloat32(), e.ReadFloat32()];
            }
            ReadChunks(e, t, r) {
                for (; e.GetPosition() <= t - 6; ) {
                    let i = e.ReadUnsignedInteger16(),
                        n = e.ReadUnsignedInteger32();
                    r(i, n);
                }
            }
            GetChunkEnd(e, t) {
                return e.GetPosition() + t - 6;
            }
            SkipChunk(e, t) {
                e.Skip(t - 6);
            }
        };
    var ge = {
            BYTE: 5120,
            UNSIGNED_BYTE: 5121,
            SHORT: 5122,
            UNSIGNED_SHORT: 5123,
            UNSIGNED_INT: 5125,
            FLOAT: 5126,
        },
        De = {
            SCALAR: 0,
            VEC2: 1,
            VEC3: 2,
            VEC4: 3,
            MAT2: 4,
            MAT3: 5,
            MAT4: 6,
        },
        gt = {
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
        },
        Ui = {
            GLTF_STRING: 1179937895,
            JSON_CHUNK_TYPE: 1313821514,
            BINARY_CHUNK_TYPE: 5130562,
        };
    function Rr(s) {
        return be(dt(s[0]), dt(s[1]), dt(s[2]));
    }
    function Wn(s, e) {
        function t(r, i) {
            let n = r;
            return (
                i === ge.UNSIGNED_BYTE
                    ? (n /= 255)
                    : i === ge.UNSIGNED_SHORT && (n /= 65535),
                he(dt(n))
            );
        }
        return new R(t(s[0], e), t(s[1], e), t(s[2], e));
    }
    var zi = class {
            constructor(e) {
                (this.reader = new de(e, !0)),
                    (this.componentType = null),
                    (this.dataType = null),
                    (this.byteStride = null),
                    (this.dataCount = null),
                    (this.sparseReader = null);
            }
            SetComponentType(e) {
                this.componentType = e;
            }
            SetDataType(e) {
                e === "SCALAR"
                    ? (this.dataType = De.SCALAR)
                    : e === "VEC2"
                    ? (this.dataType = De.VEC2)
                    : e === "VEC3"
                    ? (this.dataType = De.VEC3)
                    : e === "VEC4"
                    ? (this.dataType = De.VEC4)
                    : e === "MAT2"
                    ? (this.dataType = De.MAT2)
                    : e === "MAT3"
                    ? (this.dataType = De.MAT3)
                    : e === "MAT4" && (this.dataType = De.MAT4);
            }
            SetByteStride(e) {
                this.byteStride = e;
            }
            SetDataCount(e) {
                this.dataCount = e;
            }
            SetSparseReader(e, t) {
                this.sparseReader = { indexReader: e, valueReader: t };
            }
            ReadArrayBuffer(e) {
                return this.reader.ReadArrayBuffer(e);
            }
            GetDataCount() {
                return this.dataCount;
            }
            ReadData() {
                if (this.dataType === null) return null;
                if (this.dataType === De.SCALAR) {
                    let e = this.ReadComponent();
                    return this.SkipBytesByStride(1), e;
                } else if (this.dataType === De.VEC2) {
                    let e = this.ReadComponent(),
                        t = this.ReadComponent();
                    return this.SkipBytesByStride(2), new F(e, t);
                } else if (this.dataType === De.VEC3) {
                    let e = this.ReadComponent(),
                        t = this.ReadComponent(),
                        r = this.ReadComponent();
                    return this.SkipBytesByStride(3), new y(e, t, r);
                } else if (this.dataType === De.VEC4) {
                    let e = this.ReadComponent(),
                        t = this.ReadComponent(),
                        r = this.ReadComponent(),
                        i = this.ReadComponent();
                    return this.SkipBytesByStride(4), new Ee(e, t, r, i);
                }
                return null;
            }
            EnumerateData(e) {
                if (this.sparseReader === null)
                    for (let t = 0; t < this.dataCount; t++) e(this.ReadData());
                else {
                    let t = [];
                    for (
                        let i = 0;
                        i < this.sparseReader.indexReader.GetDataCount();
                        i++
                    ) {
                        let n = this.sparseReader.indexReader.ReadData(),
                            o = this.sparseReader.valueReader.ReadData();
                        t.push({ index: n, value: o });
                    }
                    let r = 0;
                    for (let i = 0; i < this.dataCount; i++) {
                        let n = this.ReadData();
                        r < t.length && t[r].index === i
                            ? (e(t[r].value), (r += 1))
                            : e(n);
                    }
                }
            }
            SkipBytes(e) {
                this.reader.Skip(e);
            }
            ReadComponent() {
                return this.componentType === null
                    ? null
                    : this.componentType === ge.BYTE
                    ? this.reader.ReadCharacter8()
                    : this.componentType === ge.UNSIGNED_BYTE
                    ? this.reader.ReadUnsignedCharacter8()
                    : this.componentType === ge.SHORT
                    ? this.reader.ReadInteger16()
                    : this.componentType === ge.UNSIGNED_SHORT
                    ? this.reader.ReadUnsignedInteger16()
                    : this.componentType === ge.UNSIGNED_INT
                    ? this.reader.ReadInteger32()
                    : this.componentType === ge.FLOAT
                    ? this.reader.ReadFloat32()
                    : null;
            }
            SkipBytesByStride(e) {
                if (this.byteStride === null) return;
                let t = e * this.GetComponentSize();
                this.reader.Skip(this.byteStride - t);
            }
            GetComponentSize() {
                return this.componentType === ge.BYTE ||
                    this.componentType === ge.UNSIGNED_BYTE
                    ? 1
                    : this.componentType === ge.SHORT ||
                      this.componentType === ge.UNSIGNED_SHORT
                    ? 2
                    : this.componentType === ge.UNSIGNED_INT ||
                      this.componentType === ge.FLOAT
                    ? 4
                    : 0;
            }
        },
        _i = class {
            constructor() {
                (this.supportedExtensions = [
                    "KHR_draco_mesh_compression",
                    "KHR_materials_pbrSpecularGlossiness",
                    "KHR_texture_transform",
                ]),
                    (this.draco = null);
            }
            LoadLibraries(e, t) {
                if (e === void 0) {
                    t.onSuccess();
                    return;
                }
                this.draco === null &&
                e.indexOf("KHR_draco_mesh_compression") !== -1
                    ? pe("loaders/draco_decoder.js")
                          .then(() => {
                              DracoDecoderModule().then((r) => {
                                  (this.draco = r), t.onSuccess();
                              });
                          })
                          .catch(() => {
                              t.onError("Failed to load draco decoder.");
                          })
                    : t.onSuccess();
            }
            GetUnsupportedExtensions(e) {
                let t = [];
                if (e === void 0) return t;
                for (let r = 0; r < e.length; r++) {
                    let i = e[r];
                    this.supportedExtensions.indexOf(i) === -1 && t.push(i);
                }
                return t;
            }
            ProcessMaterial(e, t, r) {
                if (e.extensions === void 0) return null;
                let i = e.extensions.KHR_materials_pbrSpecularGlossiness;
                if (i === void 0) return null;
                let n = new q(),
                    o = i.diffuseFactor;
                o !== void 0 && ((n.color = Rr(o)), (n.opacity = o[3]));
                let l = i.diffuseTexture;
                l !== void 0 && (n.diffuseMap = r(l));
                let a = i.specularFactor;
                a !== void 0 && (n.specular = Rr(a));
                let u = i.specularGlossinessTexture;
                u !== void 0 && (n.specularMap = r(u));
                let h = i.glossinessFactor;
                return h !== void 0 && (n.shininess = h), n;
            }
            ProcessTexture(e, t) {
                if (e.extensions === void 0) return;
                let r = e.extensions.KHR_texture_transform;
                r !== void 0 &&
                    (r.offset !== void 0 &&
                        ((t.offset.x = r.offset[0]),
                        (t.offset.y = -r.offset[1])),
                    r.scale !== void 0 &&
                        ((t.scale.x = r.scale[0]), (t.scale.y = r.scale[1])),
                    r.rotation !== void 0 && (t.rotation = -r.rotation));
            }
            ProcessPrimitive(e, t, r, i) {
                function n(N, D, V, Y, O) {
                    let Te = D.GetAttributeByUniqueId(V, Y),
                        Ve = Te.num_components(),
                        Tt = V.num_points() * Ve,
                        yt = Tt * 4,
                        st = N._malloc(yt);
                    D.GetAttributeDataArrayForAllPoints(
                        V,
                        Te,
                        N.DT_FLOAT32,
                        yt,
                        st
                    );
                    let ie = new Float32Array(N.HEAPF32.buffer, st, Tt).slice();
                    if (Ve === 2)
                        for (let W = 0; W < ie.length; W += 2)
                            O(new F(ie[W + 0], ie[W + 1]));
                    else if (Ve === 3)
                        for (let W = 0; W < ie.length; W += 3)
                            O(new y(ie[W + 0], ie[W + 1], ie[W + 2]));
                    else if (Ve === 4)
                        for (let W = 0; W < ie.length; W += 4)
                            O(
                                new Ee(
                                    ie[W + 0],
                                    ie[W + 1],
                                    ie[W + 2],
                                    ie[W + 3]
                                )
                            );
                    N._free(st);
                }
                if (
                    this.draco === null ||
                    r.extensions === void 0 ||
                    r.extensions.KHR_draco_mesh_compression === void 0
                )
                    return !1;
                let o = new this.draco.Decoder(),
                    l = new this.draco.DecoderBuffer(),
                    a = r.extensions.KHR_draco_mesh_compression,
                    u = t.bufferViews[a.bufferView],
                    f = e
                        .GetReaderFromBufferView(u)
                        .ReadArrayBuffer(u.byteLength);
                if (
                    (l.Init(new Int8Array(f), f.byteLength),
                    o.GetEncodedGeometryType(l) !== this.draco.TRIANGULAR_MESH)
                )
                    return !0;
                let c = new this.draco.Mesh();
                if (!o.DecodeBufferToMesh(l, c).ok()) return !0;
                let m = a.attributes.POSITION !== void 0,
                    x = !1,
                    g = a.attributes.NORMAL !== void 0,
                    C = a.attributes.TEXCOORD_0 !== void 0;
                if (!m) return !0;
                let E = i.VertexCount(),
                    T = i.VertexColorCount(),
                    M = i.NormalCount(),
                    S = i.TextureUVCount();
                n(this.draco, o, c, a.attributes.POSITION, (N) => {
                    i.AddVertex(N);
                }),
                    g &&
                        n(this.draco, o, c, a.attributes.NORMAL, (N) => {
                            i.AddNormal(N);
                        }),
                    C &&
                        n(this.draco, o, c, a.attributes.TEXCOORD_0, (N) => {
                            (N.y = -N.y), i.AddTextureUV(N);
                        });
                let v = c.num_faces() * 3,
                    b = v * 4,
                    G = this.draco._malloc(b);
                o.GetTrianglesUInt32Array(c, b, G);
                let P = new Uint32Array(
                    this.draco.HEAPU32.buffer,
                    G,
                    v
                ).slice();
                for (let N = 0; N < P.length; N += 3) {
                    let D = P[N],
                        V = P[N + 1],
                        Y = P[N + 2];
                    e.AddTriangle(r, i, D, V, Y, x, g, C, E, T, M, S);
                }
                return this.draco._free(G), !0;
            }
        },
        qt = class extends _ {
            constructor() {
                super(), (this.gltfExtensions = new _i());
            }
            CanImportExtension(e) {
                return e === "gltf" || e === "glb";
            }
            GetUpDirection() {
                return w.Y;
            }
            ClearContent() {
                (this.bufferContents = null),
                    (this.imageIndexToTextureParams = null);
            }
            ResetContent() {
                (this.bufferContents = []),
                    (this.imageIndexToTextureParams = new Map());
            }
            ImportContent(e, t) {
                this.extension === "gltf"
                    ? this.ProcessGltf(e, t)
                    : this.extension === "glb" && this.ProcessBinaryGltf(e, t);
            }
            ProcessGltf(e, t) {
                let r = K(e),
                    i = JSON.parse(r);
                if (i.asset.version !== "2.0") {
                    this.SetError("Invalid glTF version."), t();
                    return;
                }
                for (let n = 0; n < i.buffers.length; n++) {
                    let o = null,
                        l = i.buffers[n],
                        a = at(l.uri);
                    if (a !== null) o = a.buffer;
                    else {
                        let u = this.callbacks.getFileBuffer(l.uri);
                        u !== null && (o = u);
                    }
                    if (o === null) {
                        this.SetError(
                            "One of the requested buffers is missing."
                        ),
                            t();
                        return;
                    }
                    this.bufferContents.push(o);
                }
                this.ProcessMainFile(i, t);
            }
            ProcessBinaryGltf(e, t) {
                function r(u) {
                    let h = u.ReadUnsignedInteger32(),
                        f = u.ReadUnsignedInteger32(),
                        d = u.ReadArrayBuffer(h);
                    return { type: f, buffer: d };
                }
                let i = new de(e, !0);
                if (i.ReadUnsignedInteger32() !== Ui.GLTF_STRING) {
                    this.SetError("Invalid glTF file."), t();
                    return;
                }
                if (i.ReadUnsignedInteger32() !== 2) {
                    this.SetError("Invalid glTF version."), t();
                    return;
                }
                if (i.ReadUnsignedInteger32() !== i.GetByteLength()) {
                    this.SetError("Invalid glTF file."), t();
                    return;
                }
                let a = null;
                for (; !i.End(); ) {
                    let u = r(i);
                    u.type === Ui.JSON_CHUNK_TYPE
                        ? (a = K(u.buffer))
                        : u.type === Ui.BINARY_CHUNK_TYPE &&
                          this.bufferContents.push(u.buffer);
                }
                if (a !== null) {
                    let u = JSON.parse(a);
                    this.ProcessMainFile(u, t);
                }
            }
            ProcessMainFile(e, t) {
                let r = this.gltfExtensions.GetUnsupportedExtensions(
                    e.extensionsRequired
                );
                if (r.length > 0) {
                    this.SetError(
                        "Unsupported extension: " + r.join(", ") + "."
                    ),
                        t();
                    return;
                }
                this.gltfExtensions.LoadLibraries(e.extensionsRequired, {
                    onSuccess: () => {
                        this.ImportModel(e), t();
                    },
                    onError: (i) => {
                        this.SetError(i), t();
                    },
                });
            }
            ImportModel(e) {
                let t = e.materials;
                if (t !== void 0) for (let i of t) this.ImportMaterial(e, i);
                let r = e.meshes;
                if (r !== void 0) for (let i of r) this.ImportMesh(e, i);
                this.ImportNodes(e), this.ImportModelProperties(e);
            }
            ImportModelProperties(e) {
                function t(r, i, n) {
                    let o = new ae(i);
                    for (let l in n)
                        if (
                            Object.prototype.hasOwnProperty.call(n, l) &&
                            typeof n[l] == "string"
                        ) {
                            let a = new J(X.Text, l, n[l]);
                            o.AddProperty(a);
                        }
                    return o.PropertyCount() > 0 && r.AddPropertyGroup(o), o;
                }
                t(this.model, "Asset properties", e.asset),
                    e.asset.extras && t(this.model, "Extras", e.asset.extras);
            }
            GetDefaultScene(e) {
                let t = e.scene || 0;
                return t >= e.scenes.length ? null : e.scenes[t];
            }
            ImportMaterial(e, t) {
                let r = new _e();
                if (
                    (t.name !== void 0 && (r.name = t.name),
                    (r.color = Rr([1, 1, 1])),
                    t.pbrMetallicRoughness !== void 0)
                ) {
                    let n = t.pbrMetallicRoughness.baseColorFactor;
                    n !== void 0 && ((r.color = Rr(n)), (r.opacity = n[3]));
                    let o = t.pbrMetallicRoughness.metallicFactor;
                    o !== void 0 && (r.metalness = o);
                    let l = t.pbrMetallicRoughness.roughnessFactor;
                    l !== void 0 && (r.roughness = l);
                    let a = t.emissiveFactor;
                    a !== void 0 && (r.emissive = Rr(a)),
                        (r.diffuseMap = this.ImportTexture(
                            e,
                            t.pbrMetallicRoughness.baseColorTexture
                        )),
                        (r.metalnessMap = this.ImportTexture(
                            e,
                            t.pbrMetallicRoughness.metallicRoughnessTexture
                        )),
                        (r.normalMap = this.ImportTexture(e, t.normalTexture)),
                        (r.emissiveMap = this.ImportTexture(
                            e,
                            t.emissiveTexture
                        )),
                        r.diffuseMap !== null && (r.multiplyDiffuseMap = !0);
                    let u = t.alphaMode;
                    u !== void 0 &&
                        (u === "BLEND"
                            ? (r.transparent = !0)
                            : u === "MASK" &&
                              ((r.transparent = !0),
                              (r.alphaTest = t.alphaCutoff || 0.5)));
                }
                let i = this.gltfExtensions.ProcessMaterial(t, r, (n) =>
                    this.ImportTexture(e, n)
                );
                i !== null && (r = i), this.model.AddMaterial(r);
            }
            ImportTexture(e, t) {
                if (t == null) return null;
                let r = new ce(),
                    n = e.textures[t.index].source,
                    o = e.images[n],
                    l = null;
                if (this.imageIndexToTextureParams.has(n))
                    l = this.imageIndexToTextureParams.get(n);
                else {
                    l = { name: null, mimeType: null, buffer: null };
                    let a = n.toString();
                    if (o.uri !== void 0) {
                        let u = at(o.uri);
                        if (u !== null)
                            (l.name = "Embedded_" + a + "." + Qe(u.mimeType)),
                                (l.mimeType = u.mimeType),
                                (l.buffer = u.buffer);
                        else {
                            let h = this.callbacks.getFileBuffer(o.uri);
                            (l.name = o.uri), (l.buffer = h);
                        }
                    } else if (o.bufferView !== void 0) {
                        let u = e.bufferViews[o.bufferView],
                            h = this.GetReaderFromBufferView(u);
                        if (h !== null) {
                            let f = h.ReadArrayBuffer(u.byteLength);
                            (l.name = "Binary_" + a + "." + Qe(o.mimeType)),
                                (l.mimeType = o.mimeType),
                                (l.buffer = f);
                        }
                    }
                    this.imageIndexToTextureParams.set(n, l);
                }
                return (
                    (r.name = l.name),
                    (r.mimeType = l.mimeType),
                    (r.buffer = l.buffer),
                    this.gltfExtensions.ProcessTexture(t, r),
                    r
                );
            }
            ImportMesh(e, t) {
                let r = new k();
                this.model.AddMesh(r), t.name !== void 0 && r.SetName(t.name);
                for (let i = 0; i < t.primitives.length; i++) {
                    let n = t.primitives[i];
                    this.ImportPrimitive(e, n, r);
                }
            }
            ImportPrimitive(e, t, r) {
                if (
                    this.gltfExtensions.ProcessPrimitive(this, e, t, r) ||
                    t.attributes === void 0
                )
                    return;
                let i = t.attributes.POSITION !== void 0,
                    n = t.attributes.COLOR_0 !== void 0,
                    o = t.attributes.NORMAL !== void 0,
                    l = t.attributes.TEXCOORD_0 !== void 0,
                    a = t.indices !== void 0,
                    u = gt.TRIANGLES;
                if (
                    (t.mode !== void 0 && (u = t.mode),
                    u !== gt.TRIANGLES &&
                        u !== gt.TRIANGLE_STRIP &&
                        u !== gt.TRIANGLE_FAN)
                )
                    return;
                let h = r.VertexCount(),
                    f = r.VertexColorCount(),
                    d = r.NormalCount(),
                    c = r.TextureUVCount();
                if (i) {
                    let m = e.accessors[t.attributes.POSITION],
                        x = this.GetReaderFromAccessor(e, m);
                    if (x === null) return;
                    x.EnumerateData((g) => {
                        r.AddVertex(g);
                    });
                } else return;
                if (n) {
                    let m = e.accessors[t.attributes.COLOR_0],
                        x = this.GetReaderFromAccessor(e, m);
                    if (x === null) return;
                    x.EnumerateData((g) => {
                        let C = Wn([g.x, g.y, g.z], x.componentType);
                        r.AddVertexColor(C);
                    });
                }
                if (o) {
                    let m = e.accessors[t.attributes.NORMAL],
                        x = this.GetReaderFromAccessor(e, m);
                    if (x === null) return;
                    x.EnumerateData((g) => {
                        r.AddNormal(g);
                    });
                }
                if (l) {
                    let m = e.accessors[t.attributes.TEXCOORD_0],
                        x = this.GetReaderFromAccessor(e, m);
                    if (x === null) return;
                    x.EnumerateData((g) => {
                        (g.y = -g.y), r.AddTextureUV(g);
                    });
                }
                let p = [];
                if (a) {
                    let m = e.accessors[t.indices],
                        x = this.GetReaderFromAccessor(e, m);
                    if (x === null) return;
                    x.EnumerateData((g) => {
                        p.push(g);
                    });
                } else {
                    let m = r.VertexCount() - h;
                    for (let x = 0; x < m; x++) p.push(x);
                }
                if (u === gt.TRIANGLES)
                    for (let m = 0; m < p.length; m += 3) {
                        let x = p[m],
                            g = p[m + 1],
                            C = p[m + 2];
                        this.AddTriangle(t, r, x, g, C, n, o, l, h, f, d, c);
                    }
                else if (u === gt.TRIANGLE_STRIP)
                    for (let m = 0; m < p.length - 2; m++) {
                        let x = p[m],
                            g = p[m + 1],
                            C = p[m + 2];
                        if (m % 2 === 1) {
                            let E = g;
                            (g = C), (C = E);
                        }
                        this.AddTriangle(t, r, x, g, C, n, o, l, h, f, d, c);
                    }
                else if (u === gt.TRIANGLE_FAN)
                    for (let m = 1; m < p.length - 1; m++) {
                        let x = p[0],
                            g = p[m],
                            C = p[m + 1];
                        this.AddTriangle(t, r, x, g, C, n, o, l, h, f, d, c);
                    }
            }
            AddTriangle(e, t, r, i, n, o, l, a, u, h, f, d) {
                let c = new z(u + r, u + i, u + n);
                o && c.SetVertexColors(h + r, h + i, h + n),
                    l && c.SetNormals(f + r, f + i, f + n),
                    a && c.SetTextureUVs(d + r, d + i, d + n),
                    e.material !== void 0 && (c.mat = e.material),
                    t.AddTriangle(c);
            }
            ImportNodes(e) {
                let t = this.GetDefaultScene(e);
                if (t === null) return;
                let r = this.model.GetRootNode();
                for (let i of t.nodes) {
                    let n = e.nodes[i];
                    this.ImportNode(e, n, r);
                }
            }
            ImportNode(e, t, r) {
                function i(o) {
                    let l = new L().CreateIdentity();
                    if (o.matrix !== void 0) l.Set(o.matrix);
                    else {
                        let a = [0, 0, 0],
                            u = [0, 0, 0, 1],
                            h = [1, 1, 1];
                        o.translation !== void 0 && (a = o.translation),
                            o.rotation !== void 0 && (u = o.rotation),
                            o.scale !== void 0 && (h = o.scale),
                            l.ComposeTRS(Re(a), $e(u), Re(h));
                    }
                    return new H(l);
                }
                if (t.children === void 0 && t.mesh === void 0) return;
                let n = new ue();
                if (
                    (t.name !== void 0 && n.SetName(t.name),
                    n.SetTransformation(i(t)),
                    r.AddChildNode(n),
                    t.children !== void 0)
                )
                    for (let o of t.children) {
                        let l = e.nodes[o];
                        this.ImportNode(e, l, n);
                    }
                t.mesh !== void 0 &&
                    ((t.children === void 0 || t.children.length === 0) &&
                        n.SetType(Me.MeshNode),
                    n.AddMeshIndex(t.mesh));
            }
            GetReaderFromBufferView(e) {
                let t = e.buffer || 0,
                    r = this.bufferContents[t];
                if (r == null) return null;
                let i = new zi(r);
                i.SkipBytes(e.byteOffset || 0);
                let n = e.byteStride;
                return n !== void 0 && n !== 0 && i.SetByteStride(n), i;
            }
            GetReaderFromAccessor(e, t) {
                let r = t.bufferView || 0,
                    i = e.bufferViews[r],
                    n = this.GetReaderFromBufferView(i);
                if (n === null) return null;
                if (
                    (n.SetComponentType(t.componentType),
                    n.SetDataType(t.type),
                    n.SetDataCount(t.count),
                    n.SkipBytes(t.byteOffset || 0),
                    t.sparse !== void 0)
                ) {
                    let o = this.GetReaderFromSparseAccessor(
                            e,
                            t.sparse.indices,
                            t.sparse.indices.componentType,
                            "SCALAR",
                            t.sparse.count
                        ),
                        l = this.GetReaderFromSparseAccessor(
                            e,
                            t.sparse.values,
                            t.componentType,
                            t.type,
                            t.sparse.count
                        );
                    o !== null && l !== null && n.SetSparseReader(o, l);
                }
                return n;
            }
            GetReaderFromSparseAccessor(e, t, r, i, n) {
                if (t.bufferView === void 0) return null;
                let o = e.bufferViews[t.bufferView],
                    l = this.GetReaderFromBufferView(o);
                return l === null
                    ? null
                    : (l.SetComponentType(r),
                      l.SetDataType(i),
                      l.SetDataCount(n),
                      l.SkipBytes(t.byteOffset || 0),
                      l);
            }
        };
    var Xt = class extends _ {
        constructor() {
            super();
        }
        CanImportExtension(e) {
            return e === "stl";
        }
        GetUpDirection() {
            return w.Z;
        }
        ClearContent() {
            (this.mesh = null), (this.triangle = null);
        }
        ResetContent() {
            (this.mesh = new k()),
                this.model.AddMeshToRootNode(this.mesh),
                (this.triangle = null);
        }
        ImportContent(e, t) {
            if (this.IsBinaryStlFile(e)) this.ProcessBinary(e);
            else {
                let r = K(e);
                ve(r, (i) => {
                    this.WasError() || this.ProcessLine(i);
                });
            }
            t();
        }
        IsBinaryStlFile(e) {
            let t = e.byteLength;
            if (t < 84) return !1;
            let r = new de(e, !0);
            r.Skip(80);
            let i = r.ReadUnsignedInteger32();
            return t === i * 50 + 84;
        }
        ProcessLine(e) {
            if (e[0] === "#") return;
            let t = Ne(e, "#");
            if (t.length === 0) return;
            let r = t[0];
            if (r === "solid") {
                if (t.length > 1) {
                    let i = He(e, r.length, "#");
                    this.mesh.SetName(i);
                }
                return;
            }
            if (r === "facet") {
                if (
                    ((this.triangle = new z(-1, -1, -1)),
                    t.length >= 5 && t[1] === "normal")
                ) {
                    let i = new y(
                        parseFloat(t[2]),
                        parseFloat(t[3]),
                        parseFloat(t[4])
                    );
                    if (Se(i.Length())) {
                        let n = this.mesh.AddNormal(i);
                        this.triangle.SetNormals(n, n, n);
                    }
                }
                return;
            }
            if (r === "vertex" && this.triangle !== null) {
                if (t.length >= 4) {
                    let i = this.mesh.AddVertex(
                        new y(
                            parseFloat(t[1]),
                            parseFloat(t[2]),
                            parseFloat(t[3])
                        )
                    );
                    this.triangle.v0 === -1
                        ? (this.triangle.v0 = i)
                        : this.triangle.v1 === -1
                        ? (this.triangle.v1 = i)
                        : this.triangle.v2 === -1 && (this.triangle.v2 = i);
                }
                return;
            }
            if (r === "endfacet" && this.triangle !== null) {
                this.triangle.v0 !== -1 &&
                    this.triangle.v1 !== -1 &&
                    this.triangle.v2 !== null &&
                    this.mesh.AddTriangle(this.triangle),
                    (this.triangle = null);
                return;
            }
        }
        ProcessBinary(e) {
            function t(o) {
                let l = new y();
                return (
                    (l.x = o.ReadFloat32()),
                    (l.y = o.ReadFloat32()),
                    (l.z = o.ReadFloat32()),
                    l
                );
            }
            function r(o, l) {
                let a = t(l);
                return o.AddVertex(a);
            }
            let i = new de(e, !0);
            i.Skip(80);
            let n = i.ReadUnsignedInteger32();
            for (let o = 0; o < n; o++) {
                let l = t(i),
                    a = r(this.mesh, i),
                    u = r(this.mesh, i),
                    h = r(this.mesh, i);
                i.Skip(2);
                let f = new z(a, u, h);
                if (Se(l.Length())) {
                    let d = this.mesh.AddNormal(l);
                    f.SetNormals(d, d, d);
                }
                this.mesh.AddTriangle(f);
            }
        }
    };
    var Hi = class {
        constructor(e) {
            (this.mesh = e),
                (this.globalToMeshVertices = new Map()),
                (this.globalToMeshVertexColors = new Map()),
                (this.globalToMeshNormals = new Map()),
                (this.globalToMeshUvs = new Map());
        }
        AddVertex(e, t) {
            return this.GetLocalIndex(e, t, this.globalToMeshVertices, (r) =>
                this.mesh.AddVertex(new y(r.x, r.y, r.z))
            );
        }
        AddVertexColor(e, t) {
            return this.GetLocalIndex(
                e,
                t,
                this.globalToMeshVertexColors,
                (r) => this.mesh.AddVertexColor(new R(r.r, r.g, r.b))
            );
        }
        AddNormal(e, t) {
            return this.GetLocalIndex(e, t, this.globalToMeshNormals, (r) =>
                this.mesh.AddNormal(new y(r.x, r.y, r.z))
            );
        }
        AddUV(e, t) {
            return this.GetLocalIndex(e, t, this.globalToMeshUvs, (r) =>
                this.mesh.AddTextureUV(new F(r.x, r.y))
            );
        }
        AddTriangle(e) {
            this.mesh.AddTriangle(e);
        }
        GetLocalIndex(e, t, r, i) {
            if (isNaN(e) || e < 0 || e >= t.length) return null;
            if (r.has(e)) return r.get(e);
            {
                let n = t[e],
                    o = i(n);
                return r.set(e, o), o;
            }
        }
    };
    function pi(s, e, t) {
        return be(parseFloat(s), parseFloat(e), parseFloat(t));
    }
    var Yt = class extends _ {
        constructor() {
            super();
        }
        CanImportExtension(e) {
            return e === "obj";
        }
        GetUpDirection() {
            return w.Y;
        }
        ClearContent() {
            (this.globalVertices = null),
                (this.globalVertexColors = null),
                (this.globalNormals = null),
                (this.globalUvs = null),
                (this.currentMeshConverter = null),
                (this.currentMaterial = null),
                (this.currentMaterialIndex = null),
                (this.meshNameToConverter = null),
                (this.materialNameToIndex = null);
        }
        ResetContent() {
            (this.globalVertices = []),
                (this.globalVertexColors = []),
                (this.globalNormals = []),
                (this.globalUvs = []),
                (this.currentMeshConverter = null),
                (this.currentMaterial = null),
                (this.currentMaterialIndex = null),
                (this.meshNameToConverter = new Map()),
                (this.materialNameToIndex = new Map());
        }
        ImportContent(e, t) {
            let r = K(e);
            ve(r, (i) => {
                this.WasError() || this.ProcessLine(i);
            }),
                t();
        }
        ProcessLine(e) {
            if (e[0] === "#") return;
            let t = Ne(e, "#");
            if (t.length === 0) return;
            let r = t[0].toLowerCase();
            t.shift(),
                !this.ProcessMeshParameter(r, t, e) &&
                    this.ProcessMaterialParameter(r, t, e);
        }
        AddNewMesh(e) {
            if (this.meshNameToConverter.has(e))
                this.currentMeshConverter = this.meshNameToConverter.get(e);
            else {
                let t = new k();
                t.SetName(e),
                    this.model.AddMeshToRootNode(t),
                    (this.currentMeshConverter = new Hi(t)),
                    this.meshNameToConverter.set(e, this.currentMeshConverter);
            }
        }
        ProcessMeshParameter(e, t, r) {
            if (e === "g" || e === "o") {
                if (t.length === 0) return !0;
                let i = He(r, e.length, "#");
                return this.AddNewMesh(i), !0;
            } else {
                if (e === "v")
                    return (
                        t.length < 3 ||
                            (this.globalVertices.push(
                                new y(
                                    parseFloat(t[0]),
                                    parseFloat(t[1]),
                                    parseFloat(t[2])
                                )
                            ),
                            t.length >= 6 &&
                                this.globalVertexColors.push(
                                    pi(t[3], t[4], t[5])
                                )),
                        !0
                    );
                if (e === "vn")
                    return (
                        t.length < 3 ||
                            this.globalNormals.push(
                                new y(
                                    parseFloat(t[0]),
                                    parseFloat(t[1]),
                                    parseFloat(t[2])
                                )
                            ),
                        !0
                    );
                if (e === "vt")
                    return (
                        t.length < 2 ||
                            this.globalUvs.push(
                                new F(parseFloat(t[0]), parseFloat(t[1]))
                            ),
                        !0
                    );
                if (e === "f") return t.length < 3 || this.ProcessFace(t), !0;
            }
            return !1;
        }
        ProcessMaterialParameter(e, t, r) {
            function i(n, o, l) {
                let a = new ce(),
                    u = He(o, n.length, "#"),
                    h = l.getFileBuffer(u);
                return (a.name = u), (a.buffer = h), a;
            }
            if (e === "newmtl") {
                if (t.length === 0) return !0;
                let n = new q(),
                    o = He(r, e.length, "#"),
                    l = this.model.AddMaterial(n);
                return (
                    (n.name = o),
                    (this.currentMaterial = n),
                    this.materialNameToIndex.set(o, l),
                    !0
                );
            } else if (e === "usemtl") {
                if (t.length === 0) return !0;
                let n = He(r, e.length, "#");
                return (
                    this.materialNameToIndex.has(n) &&
                        (this.currentMaterialIndex =
                            this.materialNameToIndex.get(n)),
                    !0
                );
            } else if (e === "mtllib") {
                if (t.length === 0) return !0;
                let n = He(r, e.length, "#"),
                    o = this.callbacks.getFileBuffer(n);
                if (o !== null) {
                    let l = K(o);
                    ve(l, (a) => {
                        this.WasError() || this.ProcessLine(a);
                    });
                }
                return !0;
            } else {
                if (e === "map_kd")
                    return (
                        this.currentMaterial === null ||
                            t.length === 0 ||
                            ((this.currentMaterial.diffuseMap = i(
                                e,
                                r,
                                this.callbacks
                            )),
                            le(this.currentMaterial)),
                        !0
                    );
                if (e === "map_ks")
                    return (
                        this.currentMaterial === null ||
                            t.length === 0 ||
                            (this.currentMaterial.specularMap = i(
                                e,
                                r,
                                this.callbacks
                            )),
                        !0
                    );
                if (e === "map_bump" || e === "bump")
                    return (
                        this.currentMaterial === null ||
                            t.length === 0 ||
                            (this.currentMaterial.bumpMap = i(
                                e,
                                r,
                                this.callbacks
                            )),
                        !0
                    );
                if (e === "ka")
                    return (
                        this.currentMaterial === null ||
                            t.length < 3 ||
                            (this.currentMaterial.ambient = pi(
                                t[0],
                                t[1],
                                t[2]
                            )),
                        !0
                    );
                if (e === "kd")
                    return (
                        this.currentMaterial === null ||
                            t.length < 3 ||
                            (this.currentMaterial.color = pi(t[0], t[1], t[2])),
                        !0
                    );
                if (e === "ks")
                    return (
                        this.currentMaterial === null ||
                            t.length < 3 ||
                            (this.currentMaterial.specular = pi(
                                t[0],
                                t[1],
                                t[2]
                            )),
                        !0
                    );
                if (e === "ns")
                    return (
                        this.currentMaterial === null ||
                            t.length < 1 ||
                            (this.currentMaterial.shininess =
                                parseFloat(t[0]) / 1e3),
                        !0
                    );
                if (e === "tr")
                    return (
                        this.currentMaterial === null ||
                            t.length < 1 ||
                            ((this.currentMaterial.opacity =
                                1 - parseFloat(t[0])),
                            le(this.currentMaterial)),
                        !0
                    );
                if (e === "d")
                    return (
                        this.currentMaterial === null ||
                            t.length < 1 ||
                            ((this.currentMaterial.opacity = parseFloat(t[0])),
                            le(this.currentMaterial)),
                        !0
                    );
            }
            return !1;
        }
        ProcessFace(e) {
            function t(l, a) {
                return l > 0 ? l - 1 : a + l;
            }
            let r = [],
                i = [],
                n = [],
                o = [];
            for (let l = 0; l < e.length; l++) {
                let a = e[l].split("/");
                r.push(t(parseInt(a[0], 10), this.globalVertices.length)),
                    this.globalVertices.length ===
                        this.globalVertexColors.length &&
                        i.push(
                            t(parseInt(a[0], 10), this.globalVertices.length)
                        ),
                    a.length > 1 &&
                        a[1].length > 0 &&
                        o.push(t(parseInt(a[1], 10), this.globalUvs.length)),
                    a.length > 2 &&
                        a[2].length > 0 &&
                        n.push(
                            t(parseInt(a[2], 10), this.globalNormals.length)
                        );
            }
            this.currentMeshConverter === null && this.AddNewMesh("");
            for (let l = 0; l < r.length - 2; l++) {
                let a = this.currentMeshConverter.AddVertex(
                        r[0],
                        this.globalVertices
                    ),
                    u = this.currentMeshConverter.AddVertex(
                        r[l + 1],
                        this.globalVertices
                    ),
                    h = this.currentMeshConverter.AddVertex(
                        r[l + 2],
                        this.globalVertices
                    );
                if (a === null || u === null || h === null) {
                    this.SetError("Invalid vertex index.");
                    break;
                }
                let f = new z(a, u, h);
                if (i.length === r.length) {
                    let d = this.currentMeshConverter.AddVertexColor(
                            i[0],
                            this.globalVertexColors
                        ),
                        c = this.currentMeshConverter.AddVertexColor(
                            i[l + 1],
                            this.globalVertexColors
                        ),
                        p = this.currentMeshConverter.AddVertexColor(
                            i[l + 2],
                            this.globalVertexColors
                        );
                    if (d === null || c === null || p === null) {
                        this.SetError("Invalid vertex color index.");
                        break;
                    }
                    f.SetVertexColors(d, c, p);
                }
                if (n.length === r.length) {
                    let d = this.currentMeshConverter.AddNormal(
                            n[0],
                            this.globalNormals
                        ),
                        c = this.currentMeshConverter.AddNormal(
                            n[l + 1],
                            this.globalNormals
                        ),
                        p = this.currentMeshConverter.AddNormal(
                            n[l + 2],
                            this.globalNormals
                        );
                    if (d === null || c === null || p === null) {
                        this.SetError("Invalid normal index.");
                        break;
                    }
                    f.SetNormals(d, c, p);
                }
                if (o.length === r.length) {
                    let d = this.currentMeshConverter.AddUV(
                            o[0],
                            this.globalUvs
                        ),
                        c = this.currentMeshConverter.AddUV(
                            o[l + 1],
                            this.globalUvs
                        ),
                        p = this.currentMeshConverter.AddUV(
                            o[l + 2],
                            this.globalUvs
                        );
                    if (d === null || c === null || p === null) {
                        this.SetError("Invalid uv index.");
                        break;
                    }
                    f.SetTextureUVs(d, c, p);
                }
                this.currentMaterialIndex !== null &&
                    (f.mat = this.currentMaterialIndex),
                    this.currentMeshConverter.AddTriangle(f);
            }
        }
    };
    var rt = { Ok: 1, NoVertices: 2, NoFaces: 3, UnknownError: 4 },
        ki = class {
            constructor() {
                (this.format = null), (this.elements = []);
            }
            SetFormat(e) {
                this.format = e;
            }
            AddElement(e, t) {
                this.elements.push({ name: e, count: t, format: [] });
            }
            GetElements() {
                return this.elements;
            }
            AddSingleFormat(e, t) {
                this.elements[this.elements.length - 1].format.push({
                    name: t,
                    isSingle: !0,
                    elemType: e,
                });
            }
            AddListFormat(e, t, r) {
                this.elements[this.elements.length - 1].format.push({
                    name: r,
                    isSingle: !1,
                    countType: e,
                    elemType: t,
                });
            }
            GetElement(e) {
                for (let t = 0; t < this.elements.length; t++) {
                    let r = this.elements[t];
                    if (r.name === e) return r;
                }
                return null;
            }
            Check() {
                let e = this.GetElement("vertex");
                if (e === null || e.length === 0 || e.format.length < 3)
                    return rt.NoVertices;
                let t = this.GetElement("face");
                if (this.format === "ascii") {
                    if (t === null || t.count === 0 || t.format.length < 0)
                        return rt.NoFaces;
                } else if (
                    this.format === "binary_little_endian" ||
                    this.format === "binary_big_endian"
                ) {
                    let r = this.GetElement("tristrips"),
                        i = t !== null && t.count > 0 && t.format.length > 0,
                        n = r !== null && r.count > 0 && r.format.length > 0;
                    if (!i && !n) return rt.NoFaces;
                } else return rt.UnknownError;
                return rt.Ok;
            }
        },
        ji = class {
            constructor(e) {
                (this.model = e), (this.colorToMaterial = new Map());
            }
            GetMaterialIndexByColor(e) {
                let t = "Color " + Z(e[0]) + Z(e[1]) + Z(e[2]) + Z(e[3]);
                if (this.colorToMaterial.has(t))
                    return this.colorToMaterial.get(t);
                {
                    let r = new q();
                    (r.name = t),
                        (r.color = new R(e[0], e[1], e[2])),
                        (r.opacity = e[3] / 255),
                        le(r);
                    let i = this.model.AddMaterial(r);
                    return this.colorToMaterial.set(t, i), i;
                }
            }
        },
        Jt = class extends _ {
            constructor() {
                super();
            }
            CanImportExtension(e) {
                return e === "ply";
            }
            GetUpDirection() {
                return w.Y;
            }
            ClearContent() {
                this.mesh = null;
            }
            ResetContent() {
                (this.mesh = new k()), this.model.AddMeshToRootNode(this.mesh);
            }
            ImportContent(e, t) {
                let r = this.GetHeaderContent(e),
                    i = this.ReadHeader(r),
                    n = i.Check();
                if (n === rt.Ok)
                    if (i.format === "ascii") {
                        let o = K(e);
                        (o = o.substring(r.length)),
                            this.ReadAsciiContent(i, o);
                    } else
                        (i.format === "binary_little_endian" ||
                            i.format === "binary_big_endian") &&
                            this.ReadBinaryContent(i, e, r.length);
                else
                    n === rt.NoVertices
                        ? this.SetError("The model contains no vertices.")
                        : n === rt.NoFaces
                        ? this.SetError("The model contains no faces.")
                        : this.SetError("Invalid header information.");
                t();
            }
            GetHeaderContent(e) {
                let t = "",
                    r = new Uint8Array(e),
                    i = 0;
                for (
                    i = 0;
                    i < e.byteLength &&
                    ((t += String.fromCharCode(r[i])),
                    !t.endsWith("end_header"));
                    i++
                );
                for (i += 1; i < e.byteLength; ) {
                    let n = String.fromCharCode(r[i]);
                    if (
                        ((t += n),
                        (i += 1),
                        n ===
                            `
`)
                    )
                        break;
                }
                return t;
            }
            ReadHeader(e) {
                let t = new ki();
                return (
                    ve(e, (r) => {
                        let i = Ne(r, null);
                        i.length === 0 ||
                            i[0] === "comment" ||
                            (i[0] !== "ply" &&
                                (i[0] === "format" && i.length >= 2
                                    ? t.SetFormat(i[1])
                                    : i[0] === "element" && i.length >= 3
                                    ? t.AddElement(i[1], parseInt(i[2], 10))
                                    : i[0] === "property" &&
                                      i.length >= 3 &&
                                      (i[1] === "list" && i.length >= 5
                                          ? t.AddListFormat(i[2], i[3], i[4])
                                          : t.AddSingleFormat(i[1], i[2]))));
                    }),
                    t
                );
            }
            ReadAsciiContent(e, t) {
                let r = e.GetElement("vertex"),
                    i = e.GetElement("face"),
                    n = 0,
                    o = 0;
                ve(t, (l) => {
                    if (this.WasError()) return;
                    let a = Ne(l, null);
                    if (!(a.length === 0 || a[0] === "comment")) {
                        if (n < r.count) {
                            a.length >= 3 &&
                                (this.mesh.AddVertex(
                                    new y(
                                        parseFloat(a[0]),
                                        parseFloat(a[1]),
                                        parseFloat(a[2])
                                    )
                                ),
                                (n += 1));
                            return;
                        }
                        if (i !== null && o < i.count) {
                            if (a.length >= 4) {
                                let u = parseInt(a[0], 10);
                                if (a.length < u + 1) return;
                                for (let h = 0; h < u - 2; h++) {
                                    let f = parseInt(a[1]),
                                        d = parseInt(a[h + 2]),
                                        c = parseInt(a[h + 3]),
                                        p = new z(f, d, c);
                                    this.mesh.AddTriangle(p);
                                }
                                o += 1;
                            }
                            return;
                        }
                    }
                });
            }
            ReadBinaryContent(e, t, r) {
                function i(h, f) {
                    function d(c, p) {
                        return p === "char" || p === "int8"
                            ? c.ReadCharacter8()
                            : p === "uchar" || p === "uint8"
                            ? c.ReadUnsignedCharacter8()
                            : p === "short" || p === "int16"
                            ? c.ReadInteger16()
                            : p === "ushort" || p === "uint16"
                            ? c.ReadUnsignedInteger16()
                            : p === "int" || p === "int32"
                            ? c.ReadInteger32()
                            : p === "uint" || p === "uint32"
                            ? c.ReadUnsignedInteger32()
                            : p === "float" || p === "float32"
                            ? c.ReadFloat32()
                            : p === "double" || p === "double64"
                            ? c.ReadDouble64()
                            : null;
                    }
                    if (f.isSingle) return d(h, f.elemType);
                    {
                        let c = [],
                            p = d(h, f.countType);
                        for (let m = 0; m < p; m++) c.push(d(h, f.elemType));
                        return c;
                    }
                }
                function n(h, f, d) {
                    for (let c = d; c < f.length; c++) i(h, f[c]);
                }
                function o(h, f, d) {
                    let c = null,
                        p = null,
                        m = null,
                        x = 255;
                    for (let g = d; g < f.length; g++) {
                        let C = f[g],
                            E = i(h, C);
                        C.name === "red"
                            ? (c = E)
                            : C.name === "green"
                            ? (p = E)
                            : C.name === "blue"
                            ? (m = E)
                            : C.name === "alpha" && (x = E);
                    }
                    return c !== null && p !== null && m !== null
                        ? [c, p, m, x]
                        : null;
                }
                let l = null;
                if (e.format === "binary_little_endian") l = new de(t, !0);
                else if (e.format === "binary_big_endian") l = new de(t, !1);
                else return;
                l.Skip(r);
                let a = new ji(this.model),
                    u = e.GetElements();
                for (let h = 0; h < u.length; h++) {
                    let f = u[h];
                    if (f.name === "vertex")
                        for (let d = 0; d < f.count; d++) {
                            let c = i(l, f.format[0]),
                                p = i(l, f.format[1]),
                                m = i(l, f.format[2]),
                                x = o(l, f.format, 3);
                            x !== null &&
                                this.mesh.AddVertexColor(
                                    new R(x[0], x[1], x[2])
                                ),
                                this.mesh.AddVertex(new y(c, p, m));
                        }
                    else if (f.name === "face")
                        for (let d = 0; d < f.count; d++) {
                            let c = i(l, f.format[0]),
                                p = o(l, f.format, 1);
                            for (let m = 0; m < c.length - 2; m++) {
                                let x = c[0],
                                    g = c[m + 1],
                                    C = c[m + 2],
                                    E = new z(x, g, C);
                                p !== null
                                    ? (E.mat = a.GetMaterialIndexByColor(p))
                                    : this.mesh.VertexColorCount() > 0 &&
                                      E.SetVertexColors(x, g, C),
                                    this.mesh.AddTriangle(E);
                            }
                        }
                    else if (f.name === "tristrips")
                        for (let d = 0; d < f.count; d++) {
                            let c = i(l, f.format[0]);
                            n(l, f.format, 1);
                            let p = !0;
                            for (let m = 0; m < c.length - 2; m++) {
                                let x = c[m],
                                    g = c[m + 1],
                                    C = c[m + 2];
                                if (C === -1) {
                                    (m += 2), (p = !0);
                                    continue;
                                }
                                if (!p) {
                                    let T = g;
                                    (g = C), (C = T);
                                }
                                p = !p;
                                let E = new z(x, g, C);
                                this.mesh.AddTriangle(E);
                            }
                        }
                    else n(l, f.format, 0);
                }
            }
        };
    var Kt = class extends _ {
        constructor() {
            super(), (this.ifc = null);
        }
        CanImportExtension(e) {
            return e === "ifc";
        }
        GetUpDirection() {
            return w.Y;
        }
        ClearContent() {
            (this.materialNameToIndex = null), (this.expressIDToMesh = null);
        }
        ResetContent() {
            (this.materialNameToIndex = new Map()),
                (this.expressIDToMesh = new Map());
        }
        ImportContent(e, t) {
            this.ifc === null
                ? pe("loaders/web-ifc-api-browser.js")
                      .then(() => {
                          (this.ifc = new WebIFC.IfcAPI()),
                              this.ifc.Init().then(() => {
                                  this.ImportIfcContent(e), t();
                              });
                      })
                      .catch(() => {
                          this.SetError("Failed to load web-ifc."), t();
                      })
                : (this.ImportIfcContent(e), t());
        }
        ImportIfcContent(e) {
            let t = new Uint8Array(e),
                r = this.ifc.OpenModel(t, { COORDINATE_TO_ORIGIN: !0 }),
                i = this.ifc.LoadAllGeometry(r);
            for (let n = 0; n < i.size(); n++) {
                let o = i.get(n);
                o.geometries.size() > 0 && this.ImportIfcMesh(r, o);
            }
            this.ImportProperties(r), this.ifc.CloseModel(r);
        }
        ImportIfcMesh(e, t) {
            let r = new k();
            r.SetName("Mesh " + t.expressID.toString());
            let i = 0,
                n = t.geometries;
            for (let o = 0; o < n.size(); o++) {
                let l = n.get(o),
                    a = this.ifc.GetGeometry(e, l.geometryExpressID),
                    u = this.ifc.GetVertexArray(
                        a.GetVertexData(),
                        a.GetVertexDataSize()
                    ),
                    h = this.ifc.GetIndexArray(
                        a.GetIndexData(),
                        a.GetIndexDataSize()
                    ),
                    f = this.GetMaterialIndexByColor(l.color),
                    d = new L(l.flatTransformation),
                    c = new H(d);
                for (let p = 0; p < u.length; p += 6) {
                    let m = u[p],
                        x = u[p + 1],
                        g = u[p + 2],
                        C = new y(m, x, g),
                        E = c.TransformCoord3D(C);
                    r.AddVertex(E);
                }
                for (let p = 0; p < h.length; p += 3) {
                    let m = h[p],
                        x = h[p + 1],
                        g = h[p + 2],
                        C = new z(i + m, i + x, i + g);
                    C.SetMaterial(f), r.AddTriangle(C);
                }
                i += u.length / 6;
            }
            this.expressIDToMesh.set(t.expressID, r),
                this.model.AddMeshToRootNode(r);
        }
        ImportProperties(e) {
            let t = this.ifc.GetLineIDsWithType(
                e,
                WebIFC.IFCRELDEFINESBYPROPERTIES
            );
            for (let r = 0; r < t.size(); r++) {
                let i = t.get(r),
                    n = this.ifc.GetLine(e, i);
                Array.isArray(n.RelatingPropertyDefinition) ||
                    n.RelatedObjects.forEach((o) => {
                        let l = null;
                        if (
                            (this.expressIDToMesh.has(o.value)
                                ? (l = this.expressIDToMesh.get(o.value))
                                : this.ifc.GetLine(e, o.value, !0).type ===
                                      WebIFC.IFCBUILDING && (l = this.model),
                            l === null)
                        )
                            return;
                        let a = n.RelatingPropertyDefinition,
                            u = this.ifc.GetLine(e, a.value, !0);
                        if (!u || !u.HasProperties) return;
                        let h = new ae(u.Name.value);
                        u.HasProperties.forEach((f) => {
                            if (!f || !f.Name || !f.NominalValue) return;
                            let d = null,
                                c = this.GetIFCString(f.Name.value),
                                p = null;
                            switch (f.NominalValue.label) {
                                case "IFCTEXT":
                                case "IFCLABEL":
                                case "IFCIDENTIFIER":
                                    d = new J(
                                        X.Text,
                                        c,
                                        this.GetIFCString(f.NominalValue.value)
                                    );
                                    break;
                                case "IFCBOOLEAN":
                                case "IFCLOGICAL":
                                    (p = "Unknown"),
                                        f.NominalValue.value === "T"
                                            ? (p = "True")
                                            : f.NominalValue.value === "F" &&
                                              (p = "False"),
                                        (d = new J(X.Text, c, p));
                                    break;
                                case "IFCINTEGER":
                                case "IFCCOUNTMEASURE":
                                    d = new J(
                                        X.Integer,
                                        c,
                                        f.NominalValue.value
                                    );
                                    break;
                                case "IFCREAL":
                                case "IFCLENGTHMEASURE":
                                case "IFCPOSITIVELENGTHMEASURE":
                                case "IFCAREAMEASURE":
                                case "IFCVOLUMEMEASURE":
                                case "IFCRATIOMEASURE":
                                case "IFCPOSITIVERATIOMEASURE":
                                case "IFCMASSMEASURE":
                                case "IFCMASSPERLENGTHMEASURE":
                                case "IFCPLANEANGLEMEASURE":
                                case "IFCTHERMALTRANSMITTANCEMEASURE":
                                    d = new J(
                                        X.Number,
                                        c,
                                        f.NominalValue.value
                                    );
                                    break;
                                default:
                                    break;
                            }
                            d !== null && h.AddProperty(d);
                        }),
                            h.PropertyCount() > 0 && l.AddPropertyGroup(h);
                    });
            }
        }
        GetMaterialIndexByColor(e) {
            let t = be(e.x, e.y, e.z),
                r =
                    "Color " +
                    Z(t.r) +
                    Z(t.g) +
                    Z(t.b) +
                    Z(parseInt(e.w * 255, 10));
            if (this.materialNameToIndex.has(r))
                return this.materialNameToIndex.get(r);
            {
                let i = new q();
                (i.name = r), (i.color = t), (i.opacity = e.w), le(i);
                let n = this.model.AddMaterial(i);
                return this.materialNameToIndex.set(r, n), n;
            }
        }
        GetIFCString(e) {
            let t = this.DecodeIFCString(e);
            return t.length === 0 && (t = "-"), t;
        }
        DecodeIFCString(e) {
            let t = /\\X2\\(.*?)\\X0\\/giu,
                r = e,
                i = t.exec(e);
            for (; i; ) {
                let n = String.fromCharCode(parseInt(i[1], 16));
                (r = r.replace(i[0], n)), (i = t.exec(e));
            }
            return r;
        }
    };
    var Ct = class {
            constructor() {
                (this.name = null), (this.material = null);
            }
            SetName(e) {
                return (this.name = e), this;
            }
            SetMaterial(e) {
                return (this.material = e), this;
            }
        },
        it = class {
            constructor(e) {
                (this.params = e || new Ct()),
                    (this.mesh = new k()),
                    this.params.name !== null &&
                        this.mesh.SetName(this.params.name),
                    (this.curve = null);
            }
            GetMesh() {
                return this.mesh;
            }
            AddVertex(e, t, r) {
                let i = new y(e, t, r);
                return this.mesh.AddVertex(i);
            }
            AddVertices(e) {
                let t = [];
                for (let r = 0; r < e.length; r++) {
                    let i = e[r];
                    t.push(this.AddVertex(i.x, i.y, i.z));
                }
                return t;
            }
            SetCurve(e) {
                this.curve = e;
            }
            ResetCurve() {
                this.curve = null;
            }
            AddTriangle(e, t, r) {
                let i = new z(e, t, r);
                return (
                    this.params.material !== null &&
                        (i.mat = this.params.material),
                    this.curve !== null && i.SetCurve(this.curve),
                    this.mesh.AddTriangle(i)
                );
            }
            AddTriangleInverted(e, t, r) {
                this.AddTriangle(e, r, t);
            }
            AddConvexPolygon(e) {
                for (let t = 0; t < e.length - 2; t++)
                    this.AddTriangle(e[0], e[t + 1], e[t + 2]);
            }
            AddConvexPolygonInverted(e) {
                for (let t = 0; t < e.length - 2; t++)
                    this.AddTriangleInverted(e[0], e[t + 1], e[t + 2]);
            }
        },
        Zt = class {
            constructor(e) {
                this.generator = e;
            }
            GenerateSurfaceBetweenPolygons(e, t) {
                if (e.length !== t.length) return;
                let r = e.length;
                for (let i = 0; i < r; i++) {
                    let n = i,
                        o = i < r - 1 ? n + 1 : 0;
                    this.generator.AddConvexPolygon([e[n], e[o], t[o], t[n]]);
                }
            }
            GenerateTriangleFan(e, t) {
                let r = e.length;
                for (let i = 0; i < r; i++) {
                    let n = i,
                        o = i < r - 1 ? n + 1 : 0;
                    this.generator.AddTriangle(t, e[n], e[o]);
                }
            }
        };
    function yn(s, e) {
        return new F(s * Math.cos(e), s * Math.sin(e));
    }
    function xi(s, e, t, r) {
        if (!Se(e) || !Se(t) || !Se(r)) return null;
        let i = new it(s);
        return (
            i.AddVertex(0, 0, 0),
            i.AddVertex(e, 0, 0),
            i.AddVertex(e, t, 0),
            i.AddVertex(0, t, 0),
            i.AddVertex(0, 0, r),
            i.AddVertex(e, 0, r),
            i.AddVertex(e, t, r),
            i.AddVertex(0, t, r),
            i.AddConvexPolygon([0, 3, 2, 1]),
            i.AddConvexPolygon([0, 1, 5, 4]),
            i.AddConvexPolygon([1, 2, 6, 5]),
            i.AddConvexPolygon([2, 3, 7, 6]),
            i.AddConvexPolygon([3, 0, 4, 7]),
            i.AddConvexPolygon([4, 5, 6, 7]),
            i.GetMesh()
        );
    }
    function Fr(s, e, t, r, i, n) {
        if (qe(e) || qe(t) || !Se(r) || i < 3) return null;
        let o = lt(e),
            l = lt(t);
        if (o && l) return null;
        let a = new it(s),
            u = new Zt(a),
            h = (2 * Math.PI) / i,
            f = n ? 1 : null,
            d = [];
        if (o) d.push(a.AddVertex(0, 0, r));
        else
            for (let p = 0; p < i; p++) {
                let m = yn(e, p * h);
                d.push(a.AddVertex(m.x, m.y, r));
            }
        let c = [];
        if (l) c.push(a.AddVertex(0, 0, 0));
        else
            for (let p = 0; p < i; p++) {
                let m = yn(t, p * h);
                c.push(a.AddVertex(m.x, m.y, 0));
            }
        return (
            o
                ? (a.SetCurve(f),
                  u.GenerateTriangleFan(c, d[0]),
                  a.ResetCurve(),
                  a.AddConvexPolygonInverted(c))
                : l
                ? (a.SetCurve(f),
                  u.GenerateTriangleFan(d.slice().reverse(), c[0]),
                  a.ResetCurve(),
                  a.AddConvexPolygon(d))
                : (a.SetCurve(f),
                  u.GenerateSurfaceBetweenPolygons(c, d),
                  a.ResetCurve(),
                  a.AddConvexPolygonInverted(c),
                  a.AddConvexPolygon(d)),
            a.GetMesh()
        );
    }
    function gi(s, e, t, r, i) {
        return Fr(s, e, e, t, r, i);
    }
    function Ci(s, e, t, r) {
        function i(c, p, m) {
            return new y(
                c * Math.sin(p) * Math.cos(m),
                c * Math.sin(p) * Math.sin(m),
                c * Math.cos(p)
            );
        }
        if (!Se(e) || t < 3) return null;
        let n = new it(s),
            o = new Zt(n);
        n.SetCurve(r ? 1 : null);
        let l = [],
            a = t + 1,
            u = Math.PI / t,
            h = (2 * Math.PI) / t;
        for (let c = 1; c < a - 1; c++) {
            let p = [],
                m = c * u;
            for (let x = 0; x < t; x++) {
                let g = x * h,
                    C = i(e, m, -g);
                p.push(n.AddVertex(C.x, C.y, C.z));
            }
            c > 1 && o.GenerateSurfaceBetweenPolygons(l[l.length - 1], p),
                l.push(p);
        }
        let f = n.AddVertex(0, 0, e),
            d = n.AddVertex(0, 0, -e);
        return (
            o.GenerateTriangleFan(l[0].slice().reverse(), f),
            o.GenerateTriangleFan(l[l.length - 1], d),
            n.ResetCurve(),
            n.GetMesh()
        );
    }
    function Ti(s, e, t) {
        function r(n, o, l, a, u) {
            let h = new y(l, a, u);
            h.MultiplyScalar(o / h.Length()), n.AddVertex(h.x, h.y, h.z);
        }
        if (!Se(t)) return null;
        let i = new it(s);
        if (e === "tetrahedron") {
            let n = 1;
            r(i, t, +n, +n, +n),
                r(i, t, -n, -n, +n),
                r(i, t, -n, +n, -n),
                r(i, t, +n, -n, -n),
                i.AddTriangle(0, 1, 3),
                i.AddTriangle(0, 2, 1),
                i.AddTriangle(0, 3, 2),
                i.AddTriangle(1, 2, 3);
        } else if (e === "hexahedron") {
            let n = 1;
            r(i, t, +n, +n, +n),
                r(i, t, +n, +n, -n),
                r(i, t, +n, -n, +n),
                r(i, t, +n, -n, -n),
                r(i, t, -n, +n, +n),
                r(i, t, -n, +n, -n),
                r(i, t, -n, -n, +n),
                r(i, t, -n, -n, -n),
                i.AddConvexPolygon([0, 1, 5, 4]),
                i.AddConvexPolygon([0, 2, 3, 1]),
                i.AddConvexPolygon([0, 4, 6, 2]),
                i.AddConvexPolygon([1, 3, 7, 5]),
                i.AddConvexPolygon([2, 6, 7, 3]),
                i.AddConvexPolygon([4, 5, 7, 6]);
        } else if (e === "octahedron") {
            let n = 1,
                o = 0;
            r(i, t, +n, +o, +o),
                r(i, t, -n, +o, +o),
                r(i, t, +o, +n, +o),
                r(i, t, +o, -n, +o),
                r(i, t, +o, +o, +n),
                r(i, t, +o, +o, -n),
                i.AddTriangle(0, 2, 4),
                i.AddTriangle(0, 3, 5),
                i.AddTriangle(0, 4, 3),
                i.AddTriangle(0, 5, 2),
                i.AddTriangle(1, 2, 5),
                i.AddTriangle(1, 3, 4),
                i.AddTriangle(1, 4, 2),
                i.AddTriangle(1, 5, 3);
        } else if (e === "dodecahedron") {
            let n = 1,
                o = 0,
                l = (1 + Math.sqrt(5)) / 2,
                a = 1 / l;
            r(i, t, +n, +n, +n),
                r(i, t, +n, +n, -n),
                r(i, t, +n, -n, +n),
                r(i, t, -n, +n, +n),
                r(i, t, +n, -n, -n),
                r(i, t, -n, +n, -n),
                r(i, t, -n, -n, +n),
                r(i, t, -n, -n, -n),
                r(i, t, +o, +a, +l),
                r(i, t, +o, +a, -l),
                r(i, t, +o, -a, +l),
                r(i, t, +o, -a, -l),
                r(i, t, +a, +l, +o),
                r(i, t, +a, -l, +o),
                r(i, t, -a, +l, +o),
                r(i, t, -a, -l, +o),
                r(i, t, +l, +o, +a),
                r(i, t, -l, +o, +a),
                r(i, t, +l, +o, -a),
                r(i, t, -l, +o, -a),
                i.AddConvexPolygon([0, 8, 10, 2, 16]),
                i.AddConvexPolygon([0, 16, 18, 1, 12]),
                i.AddConvexPolygon([0, 12, 14, 3, 8]),
                i.AddConvexPolygon([1, 9, 5, 14, 12]),
                i.AddConvexPolygon([1, 18, 4, 11, 9]),
                i.AddConvexPolygon([2, 10, 6, 15, 13]),
                i.AddConvexPolygon([2, 13, 4, 18, 16]),
                i.AddConvexPolygon([3, 14, 5, 19, 17]),
                i.AddConvexPolygon([3, 17, 6, 10, 8]),
                i.AddConvexPolygon([4, 13, 15, 7, 11]),
                i.AddConvexPolygon([5, 9, 11, 7, 19]),
                i.AddConvexPolygon([6, 17, 19, 7, 15]);
        } else if (e === "icosahedron") {
            let n = 1,
                o = 0,
                l = (1 + Math.sqrt(5)) / 2;
            r(i, t, +o, +n, +l),
                r(i, t, +o, +n, -l),
                r(i, t, +o, -n, +l),
                r(i, t, +o, -n, -l),
                r(i, t, +n, +l, +o),
                r(i, t, +n, -l, +o),
                r(i, t, -n, +l, +o),
                r(i, t, -n, -l, +o),
                r(i, t, +l, +o, +n),
                r(i, t, +l, +o, -n),
                r(i, t, -l, +o, +n),
                r(i, t, -l, +o, -n),
                i.AddTriangle(0, 2, 8),
                i.AddTriangle(0, 4, 6),
                i.AddTriangle(0, 6, 10),
                i.AddTriangle(0, 8, 4),
                i.AddTriangle(0, 10, 2),
                i.AddTriangle(1, 3, 11),
                i.AddTriangle(1, 4, 9),
                i.AddTriangle(1, 6, 4),
                i.AddTriangle(1, 9, 3),
                i.AddTriangle(1, 11, 6),
                i.AddTriangle(2, 5, 8),
                i.AddTriangle(2, 7, 5),
                i.AddTriangle(2, 10, 7),
                i.AddTriangle(3, 5, 7),
                i.AddTriangle(3, 7, 11),
                i.AddTriangle(3, 9, 5),
                i.AddTriangle(4, 8, 9),
                i.AddTriangle(5, 9, 8),
                i.AddTriangle(6, 11, 10),
                i.AddTriangle(7, 10, 11);
        }
        return i.GetMesh();
    }
    var Qt = class extends _ {
        constructor() {
            super();
        }
        CanImportExtension(e) {
            return e === "o3dv";
        }
        GetUpDirection() {
            return w.Z;
        }
        ClearContent() {}
        ResetContent() {}
        ImportContent(e, t) {
            let r = K(e),
                i = JSON.parse(r);
            if (i.root === void 0) {
                t();
                return;
            }
            if (i.materials !== void 0)
                for (let o = 0; o < i.materials.length; o++) {
                    let l = i.materials[o];
                    this.ImportMaterial(l);
                }
            if (i.meshes !== void 0)
                for (let o = 0; o < i.meshes.length; o++) {
                    let l = i.meshes[o];
                    this.ImportMesh(l);
                }
            let n = i.nodes[i.root];
            this.ImportNode(i, n, this.model.GetRootNode()),
                this.ImportProperties(this.model, i),
                t();
        }
        ImportMaterial(e) {
            let t = new _e();
            t.color.Set(255, 255, 255),
                e.name !== void 0 && (t.name = e.name),
                e.color !== void 0 && (t.color = ri(e.color)),
                (t.metalness = we(e.metalness, 0)),
                (t.roughness = we(e.roughness, 1)),
                this.model.AddMaterial(t);
        }
        ImportMesh(e) {
            let t = new Ct();
            e.name !== void 0 && t.SetName(e.name),
                e.material !== void 0 && t.SetMaterial(e.material);
            let r = e.parameters;
            if (r === void 0) return;
            let i = null;
            if (e.type === "cuboid") {
                if (
                    r.size_x === void 0 ||
                    r.size_y === void 0 ||
                    r.size_z === void 0
                )
                    return;
                i = xi(t, r.size_x, r.size_y, r.size_z);
            } else if (e.type === "cylinder") {
                if (r.radius === void 0 || r.height === void 0) return;
                let n = we(r.segments, 25),
                    o = we(r.smooth, !0);
                i = gi(t, r.radius, r.height, n, o);
            } else if (e.type === "cone") {
                if (
                    r.top_radius === void 0 ||
                    r.bottom_radius === void 0 ||
                    r.height === void 0
                )
                    return;
                let n = we(r.segments, 25),
                    o = we(r.smooth, !0);
                i = Fr(t, r.top_radius, r.bottom_radius, r.height, n, o);
            } else if (e.type === "sphere") {
                if (r.radius === void 0) return;
                let n = we(r.segments, 20),
                    o = we(r.smooth, !0);
                i = Ci(t, r.radius, n, o);
            } else if (e.type === "platonic") {
                if (r.solid_type === void 0) return;
                let n = we(r.radius, 1);
                i = Ti(t, r.solid_type, n);
            }
            i !== null && (this.ImportProperties(i, e), this.model.AddMesh(i));
        }
        ImportNode(e, t, r) {
            if (
                (t.name !== void 0 && r.SetName(t.name),
                t.transformation !== void 0)
            ) {
                let i = this.GetTransformation(t.transformation);
                r.SetTransformation(i);
            }
            if (t.children !== void 0)
                for (let i of t.children) {
                    let n = e.nodes[i],
                        o = new ue();
                    r.AddChildNode(o), this.ImportNode(e, n, o);
                }
            t.mesh !== void 0 &&
                ((t.children === void 0 || t.children.length === 0) &&
                    r.SetType(Me.MeshNode),
                r.AddMeshIndex(t.mesh));
        }
        ImportProperties(e, t) {
            if (t.properties !== void 0) {
                let r = new ae("Properties");
                e.AddPropertyGroup(r);
                for (let i of t.properties) {
                    let n = new J(X.Text, i.name, i.value);
                    r.AddProperty(n);
                }
            }
        }
        GetTransformation(e) {
            let t = new y(0, 0, 0),
                r = new oe(0, 0, 0, 1),
                i = new y(1, 1, 1);
            e.translation !== void 0 && (t = Re(e.translation)),
                e.rotation !== void 0 && (r = $e(e.rotation)),
                e.scale !== void 0 && (i = Re(e.scale));
            let n = new L().ComposeTRS(t, r, i);
            return new H(n);
        }
    };
    var $t = class extends _ {
        constructor() {
            super(), (this.worker = null);
        }
        CanImportExtension(e) {
            return e === "stp" || e === "step";
        }
        GetUpDirection() {
            return w.Y;
        }
        ClearContent() {}
        ResetContent() {}
        ImportContent(e, t) {
            if (this.worker === null) {
                let n = Gr("loaders/occt-import-js-worker.js");
                this.worker = new Worker(n);
            }
            let r = (n) => {
                this.ImportStepContent(n.data, t),
                    this.worker.removeEventListener("message", r);
            };
            this.worker.addEventListener("message", r),
                this.worker.addEventListener("error", (n) => {
                    (this.worker = null),
                        this.SetError("Failed to load occt-import-js."),
                        t();
                });
            let i = new Uint8Array(e);
            this.worker.postMessage(i);
        }
        ImportStepContent(e, t) {
            if (!e.success) return;
            let r = new Ot((i) => {
                let n = new q();
                return (
                    (n.name = ze(i).toUpperCase()),
                    (n.color = i),
                    this.model.AddMaterial(n)
                );
            });
            for (let i of e.meshes) {
                let n = null;
                if (i.color) {
                    let l = be(i.color[0], i.color[1], i.color[2]);
                    n = r.GetMaterialIndex(l);
                }
                let o = Je(i, n);
                if ((i.name && o.SetName(i.name), i.face_colors))
                    for (let l of i.face_colors) {
                        let a = be(l.color[0], l.color[1], l.color[2]),
                            u = r.GetMaterialIndex(a);
                        for (let h = l.first; h <= l.last; h++)
                            o.GetTriangle(h).SetMaterial(u);
                    }
                this.model.AddMeshToRootNode(o);
            }
            t();
        }
    };
    var er = class extends _ {
        constructor() {
            super();
        }
        CanImportExtension(e) {
            return e === "bim";
        }
        GetUpDirection() {
            return w.Z;
        }
        ClearContent() {
            (this.meshIdToMesh = null), (this.colorToMaterialIndex = null);
        }
        ResetContent() {
            (this.meshIdToMesh = new Map()),
                (this.colorToMaterialIndex = new Map());
        }
        ImportContent(e, t) {
            let r = K(e),
                i = null;
            try {
                i = JSON.parse(r);
            } catch {
                this.SetError("Failed to parse bim file."), t();
                return;
            }
            for (let n of i.meshes) this.meshIdToMesh.set(n.mesh_id, n);
            this.ImportProperties(i, this.model);
            for (let n of i.elements) {
                let o = this.ImportElement(n);
                o.SetName(n.type), this.ImportProperties(n, o);
            }
            t();
        }
        ImportElement(e) {
            let t = null;
            if (e.color) {
                let d =
                    Z(e.color.r) + Z(e.color.g) + Z(e.color.b) + Z(e.color.a);
                if (this.colorToMaterialIndex.has(d))
                    t = this.colorToMaterialIndex.get(d);
                else {
                    let c = new q();
                    (c.name = d),
                        (c.color = new R(e.color.r, e.color.g, e.color.b)),
                        e.color.a < 255 &&
                            ((c.opacity = e.color.a / 255), le(c)),
                        (t = this.model.AddMaterial(c)),
                        this.colorToMaterialIndex.set(d, t);
                }
            }
            let r = this.model.GetRootNode(),
                i = this.meshIdToMesh.get(e.mesh_id),
                n = this.ImportMesh(i, t),
                o = this.model.AddMesh(n),
                l = new ue();
            l.SetType(Me.MeshNode), l.AddMeshIndex(o);
            let a = new y(0, 0, 0);
            e.vector && (a = new y(e.vector.x, e.vector.y, e.vector.z));
            let u = new oe(0, 0, 0, 1);
            e.rotation &&
                (u = new oe(
                    e.rotation.qx,
                    e.rotation.qy,
                    e.rotation.qz,
                    e.rotation.qw
                ));
            let h = new y(1, 1, 1),
                f = new L().ComposeTRS(a, u, h);
            return l.SetTransformation(new H(f)), r.AddChildNode(l), n;
        }
        ImportMesh(e, t) {
            let r = new k();
            for (let i = 0; i < e.coordinates.length; i += 3)
                r.AddVertex(
                    new y(
                        e.coordinates[i + 0],
                        e.coordinates[i + 1],
                        e.coordinates[i + 2]
                    )
                );
            for (let i = 0; i < e.indices.length; i += 3) {
                let n = new z(
                    e.indices[i + 0],
                    e.indices[i + 1],
                    e.indices[i + 2]
                );
                t !== null && n.SetMaterial(t), r.AddTriangle(n);
            }
            return r;
        }
        ImportProperties(e, t) {
            function r(o, l, a) {
                if (a == null) return;
                let u = new J(X.Text, l, a);
                o.AddProperty(u);
            }
            if (!e.info) return;
            let i = e.info,
                n = new ae("Info");
            r(n, "Guid", e.guid), r(n, "Type", e.type);
            for (let o in i)
                Object.prototype.hasOwnProperty.call(i, o) &&
                    typeof i[o] == "string" &&
                    r(n, o, i[o]);
            t.AddPropertyGroup(n);
        }
    };
    var tr = class {
            constructor() {
                this.defaultColor = new R(200, 200, 200);
            }
        },
        We = {
            NoImportableFile: 1,
            FailedToLoadFile: 2,
            ImportFailed: 3,
            UnknownError: 4,
        },
        nt = class {
            constructor(e) {
                (this.code = e), (this.mainFile = null), (this.message = null);
            }
        },
        Nr = class {
            constructor() {
                (this.model = null),
                    (this.mainFile = null),
                    (this.upVector = null),
                    (this.usedFiles = null),
                    (this.missingFiles = null);
            }
        },
        Dr = class {
            constructor(e) {
                (this.getBufferCallback = e), (this.fileBuffers = new Map());
            }
            GetFileBuffer(e) {
                let t = ee(e);
                if (this.fileBuffers.has(t)) return this.fileBuffers.get(t);
                let r = this.getBufferCallback(t);
                return this.fileBuffers.set(t, r), r;
            }
        },
        rr = class {
            constructor() {
                (this.importers = [
                    new Yt(),
                    new Xt(),
                    new Lt(),
                    new Jt(),
                    new Wt(),
                    new qt(),
                    new Qt(),
                    new er(),
                    new zt(),
                    new Kt(),
                    new $t(),
                    new _t(),
                    new Ht(),
                    new kt(),
                    new jt(),
                ]),
                    (this.fileList = new xt()),
                    (this.model = null),
                    (this.usedFiles = []),
                    (this.missingFiles = []);
            }
            AddImporter(e) {
                this.importers.push(e);
            }
            ImportFiles(e, t, r, i) {
                this.LoadFiles(e, t, () => {
                    i.onFilesLoaded(),
                        Ar(() => {
                            this.ImportLoadedFiles(r, i);
                        });
                });
            }
            LoadFiles(e, t, r) {
                let i = new xt();
                t === $.Url
                    ? i.FillFromFileUrls(e)
                    : t === $.File && i.FillFromfilesObjects(e);
                let n = !1;
                if (this.HasImportableFile(i)) n = !0;
                else {
                    let o = !1;
                    for (let l = 0; l < this.missingFiles.length; l++) {
                        let a = this.missingFiles[l];
                        i.ContainsFileByPath(a) && (o = !0);
                    }
                    if (!o) n = !0;
                    else {
                        let l = i.GetFiles();
                        this.fileList.ExtendFromFileList(l), (n = !1);
                    }
                }
                n && (this.fileList = i),
                    this.fileList.GetContent(() => {
                        this.DecompressArchives(this.fileList, () => {
                            r();
                        });
                    });
            }
            ImportLoadedFiles(e, t) {
                let r = this.GetImportableFiles(this.fileList);
                if (r.length === 0) {
                    t.onImportError(new nt(We.NoImportableFile));
                    return;
                }
                if (r.length === 1 || !t.onSelectMainFile) {
                    let i = r[0];
                    this.ImportLoadedMainFile(i, e, t);
                } else {
                    let i = r.map((n) => n.file.name);
                    t.onSelectMainFile(i, (n) => {
                        if (n === null) {
                            t.onImportError(new nt(We.NoImportableFile));
                            return;
                        }
                        Ar(() => {
                            let o = r[n];
                            this.ImportLoadedMainFile(o, e, t);
                        });
                    });
                }
            }
            ImportLoadedMainFile(e, t, r) {
                if (e === null || e.file === null || e.file.content === null) {
                    let o = new nt(We.FailedToLoadFile);
                    e !== null && e.file !== null && (o.mainFile = e.file.name),
                        r.onImportError(o);
                    return;
                }
                (this.model = null),
                    (this.usedFiles = []),
                    (this.missingFiles = []),
                    this.usedFiles.push(e.file.name);
                let i = e.importer,
                    n = new Dr((o) => {
                        let l = null,
                            a = this.fileList.FindFileByPath(o);
                        return (
                            a === null || a.content === null
                                ? (this.missingFiles.push(o), (l = null))
                                : (this.usedFiles.push(o), (l = a.content)),
                            l
                        );
                    });
                i.Import(e.file.name, e.file.extension, e.file.content, {
                    getDefaultMaterialColor: () => t.defaultColor,
                    getFileBuffer: (o) => n.GetFileBuffer(o),
                    onSuccess: () => {
                        this.model = i.GetModel();
                        let o = new Nr();
                        (o.mainFile = e.file.name),
                            (o.model = this.model),
                            (o.usedFiles = this.usedFiles),
                            (o.missingFiles = this.missingFiles),
                            (o.upVector = i.GetUpDirection()),
                            r.onImportSuccess(o);
                    },
                    onError: () => {
                        let o = new nt(We.ImportFailed);
                        (o.mainFile = e.file.name),
                            (o.message = i.GetErrorMessage()),
                            r.onImportError(o);
                    },
                    onComplete: () => {
                        i.Clear();
                    },
                });
            }
            DecompressArchives(e, t) {
                let r = e.GetFiles(),
                    i = [];
                for (let n of r) n.extension === "zip" && i.push(n);
                if (i.length === 0) {
                    t();
                    return;
                }
                pe("loaders/fflate.min.js")
                    .then(() => {
                        for (let n = 0; n < i.length; n++) {
                            let o = i[n],
                                l = new Uint8Array(o.content),
                                a = fflate.unzipSync(l);
                            for (let u in a)
                                if (
                                    Object.prototype.hasOwnProperty.call(a, u)
                                ) {
                                    let h = new pt(u, $.Decompressed);
                                    h.SetContent(a[u].buffer), e.AddFile(h);
                                }
                        }
                        t();
                    })
                    .catch(() => {
                        t();
                    });
            }
            GetFileList() {
                return this.fileList;
            }
            HasImportableFile(e) {
                return this.GetImportableFiles(e).length > 0;
            }
            GetImportableFiles(e) {
                function t(n, o) {
                    for (let l = 0; l < o.length; l++) {
                        let a = o[l];
                        if (a.CanImportExtension(n.extension)) return a;
                    }
                    return null;
                }
                let r = [],
                    i = e.GetFiles();
                for (let n = 0; n < i.length; n++) {
                    let o = i[n],
                        l = t(o, this.importers);
                    l !== null && r.push({ file: o, importer: l });
                }
                return r;
            }
        };
    var Pe = class {
        constructor(e, t) {
            (this.arrayBuffer = new ArrayBuffer(e)),
                (this.dataView = new DataView(this.arrayBuffer)),
                (this.isLittleEndian = t),
                (this.position = 0);
        }
        GetPosition() {
            return this.position;
        }
        SetPosition(e) {
            this.position = e;
        }
        End() {
            return this.position >= this.arrayBuffer.byteLength;
        }
        GetBuffer() {
            return this.arrayBuffer;
        }
        WriteArrayBuffer(e) {
            let t = new Uint8Array(e);
            new Uint8Array(this.arrayBuffer).set(t, this.position),
                (this.position += e.byteLength);
        }
        WriteBoolean8(e) {
            this.dataView.setInt8(this.position, e ? 1 : 0),
                (this.position = this.position + 1);
        }
        WriteCharacter8(e) {
            this.dataView.setInt8(this.position, e),
                (this.position = this.position + 1);
        }
        WriteUnsignedCharacter8(e) {
            this.dataView.setUint8(this.position, e),
                (this.position = this.position + 1);
        }
        WriteInteger16(e) {
            this.dataView.setInt16(this.position, e, this.isLittleEndian),
                (this.position = this.position + 2);
        }
        WriteUnsignedInteger16(e) {
            this.dataView.setUint16(this.position, e, this.isLittleEndian),
                (this.position = this.position + 2);
        }
        WriteInteger32(e) {
            this.dataView.setInt32(this.position, e, this.isLittleEndian),
                (this.position = this.position + 4);
        }
        WriteUnsignedInteger32(e) {
            this.dataView.setUint32(this.position, e, this.isLittleEndian),
                (this.position = this.position + 4);
        }
        WriteFloat32(e) {
            this.dataView.setFloat32(this.position, e, this.isLittleEndian),
                (this.position = this.position + 4);
        }
        WriteDouble64(e) {
            this.dataView.setFloat64(this.position, e, this.isLittleEndian),
                (this.position = this.position + 8);
        }
    };
    var Pr = class {
            constructor() {
                (this.indices = []),
                    (this.vertices = []),
                    (this.colors = []),
                    (this.normals = []),
                    (this.uvs = []),
                    (this.material = null);
            }
            GetBounds() {
                let e = [1 / 0, 1 / 0, 1 / 0],
                    t = [-1 / 0, -1 / 0, -1 / 0];
                for (let r = 0; r < this.vertices.length / 3; r++)
                    for (let i = 0; i < 3; i++)
                        (e[i] = Math.min(e[i], this.vertices[r * 3 + i])),
                            (t[i] = Math.max(t[i], this.vertices[r * 3 + i]));
                return { min: e, max: t };
            }
            GetByteLength(e, t) {
                let r = this.indices.length,
                    i =
                        this.vertices.length +
                        this.colors.length +
                        this.normals.length +
                        this.uvs.length;
                return r * e + i * t;
            }
        },
        Vr = class {
            constructor() {
                this.primitives = [];
            }
            PrimitiveCount() {
                return this.primitives.length;
            }
            GetPrimitive(e) {
                return this.primitives[e];
            }
            GetByteLength(e, t) {
                let r = 0;
                for (let i = 0; i < this.primitives.length; i++)
                    r += this.primitives[i].GetByteLength(e, t);
                return r;
            }
        };
    function ot(s) {
        function e(l, a, u, h) {
            function f(m, x, g) {
                return x !== null
                    ? m.GetVertexColor(x)
                    : g
                    ? new R(0, 0, 0)
                    : null;
            }
            function d(m, x, g) {
                return x !== null ? m.GetTextureUV(x) : g ? new F(0, 0) : null;
            }
            function c(m, x, g) {
                let C = m.VertexColorCount() > 0,
                    E = m.TextureUVCount() > 0,
                    T = m.GetVertex(x.vertex),
                    M = m.GetNormal(x.normal),
                    S = g.vertices.length / 3;
                g.indices.push(S), g.vertices.push(T.x, T.y, T.z);
                let I = f(m, x.color, C);
                I !== null && g.colors.push(I.r / 255, I.g / 255, I.b / 255),
                    g.normals.push(M.x, M.y, M.z);
                let v = d(m, x.uv, E);
                return (
                    v !== null && g.uvs.push(v.x, v.y),
                    { index: S, color: I, normal: M, uv: v }
                );
            }
            function p(m, x, g) {
                function C(M, S, I) {
                    if (I === null && S === null) return !0;
                    let v = f(M, S, !0);
                    return Ye(I, v);
                }
                function E(M, S, I) {
                    let v = M.GetNormal(S);
                    return ye(I, v);
                }
                function T(M, S, I) {
                    if (I === null && S === null) return !0;
                    let v = d(M, S, !0);
                    return Fe(I, v);
                }
                for (let M = 0; M < x.length; M++) {
                    let S = x[M],
                        I = C(m, g.color, S.color),
                        v = E(m, g.normal, S.normal),
                        b = T(m, g.uv, S.uv);
                    if (I && v && b) return S;
                }
                return null;
            }
            if (h.has(a.vertex)) {
                let m = h.get(a.vertex),
                    x = p(l, m, a);
                if (x !== null) u.indices.push(x.index);
                else {
                    let g = c(l, a, u);
                    m.push(g);
                }
            } else {
                let m = c(l, a, u);
                h.set(a.vertex, [m]);
            }
        }
        let t = new Vr(),
            r = s.TriangleCount();
        if (r === 0) return null;
        let i = [];
        for (let l = 0; l < r; l++) i.push(l);
        i.sort((l, a) => {
            let u = s.GetTriangle(l),
                h = s.GetTriangle(a);
            return u.mat - h.mat;
        });
        let n = null,
            o = null;
        for (let l = 0; l < i.length; l++) {
            let a = i[l],
                u = s.GetTriangle(a);
            (n === null || n.material !== u.mat) &&
                ((n = new Pr()),
                (n.material = u.mat),
                (o = new Map()),
                t.primitives.push(n));
            let h = { vertex: u.v0, color: u.c0, normal: u.n0, uv: u.u0 },
                f = { vertex: u.v1, color: u.c1, normal: u.n1, uv: u.u1 },
                d = { vertex: u.v2, color: u.c2, normal: u.n2, uv: u.u2 };
            e(s, h, n, o), e(s, f, n, o), e(s, d, n, o);
        }
        return t;
    }
    var j = class {
            constructor(e) {
                (this.name = e), (this.content = null);
            }
            GetName() {
                return this.name;
            }
            SetName(e) {
                this.name = e;
            }
            GetTextContent() {
                return K(this.content);
            }
            GetBufferContent() {
                return this.content;
            }
            SetTextContent(e) {
                let t = vt(e);
                this.content = t;
            }
            SetBufferContent(e) {
                this.content = e;
            }
        },
        te = class {
            constructor() {}
            CanExport(e, t) {
                return !1;
            }
            Export(e, t, r) {
                let i = [];
                this.ExportContent(e, t, i, () => {
                    r(i);
                });
            }
            ExportContent(e, t, r, i) {}
            GetExportedMaterialName(e) {
                return this.GetExportedName(e, "Material");
            }
            GetExportedMeshName(e) {
                return this.GetExportedName(e, "Mesh");
            }
            GetExportedName(e, t) {
                return e.length === 0 ? t : e;
            }
        };
    var ir = class extends te {
        constructor() {
            super(),
                (this.components = {
                    index: { type: 5125, size: 4 },
                    number: { type: 5126, size: 4 },
                });
        }
        CanExport(e, t) {
            return (
                (e === B.Text && t === "gltf") ||
                (e === B.Binary && t === "glb")
            );
        }
        ExportContent(e, t, r, i) {
            t === B.Text
                ? this.ExportAsciiContent(e, r)
                : t === B.Binary && this.ExportBinaryContent(e, r),
                i();
        }
        ExportAsciiContent(e, t) {
            let r = new j("model.gltf"),
                i = new j("model.bin");
            t.push(r), t.push(i);
            let n = this.GetMeshData(e),
                o = this.GetMainBuffer(n),
                l = this.GetMainJson(n);
            l.buffers.push({ uri: i.GetName(), byteLength: o.byteLength });
            let a = new Map();
            this.ExportMaterials(e, l, (u) => {
                let h = ee(u.name);
                if (a.has(h)) return a.get(h);
                {
                    let f = new j(h);
                    f.SetBufferContent(u.buffer), t.push(f);
                    let d = l.textures.length;
                    return (
                        a.set(h, d),
                        l.images.push({ uri: h }),
                        l.textures.push({ source: d }),
                        d
                    );
                }
            }),
                r.SetTextContent(JSON.stringify(l, null, 4)),
                i.SetBufferContent(o);
        }
        ExportBinaryContent(e, t) {
            function r(T) {
                let M = T % 4;
                return M === 0 ? T : T + (4 - M);
            }
            function i(T, M, S) {
                for (let I = 0; I < S; I++) T.WriteUnsignedCharacter8(M);
            }
            let n = new j("model.glb");
            t.push(n);
            let o = this.GetMeshData(e),
                l = this.GetMainBuffer(o),
                a = this.GetMainJson(o),
                u = [],
                h = l.byteLength,
                f = new Map();
            this.ExportMaterials(e, a, (T) => {
                let M = ee(T.name),
                    S = ke(T.name);
                if (f.has(M)) return f.get(M);
                {
                    let I = a.bufferViews.length,
                        v = a.textures.length;
                    f.set(M, v);
                    let b = T.buffer;
                    return (
                        u.push(b),
                        a.bufferViews.push({
                            buffer: 0,
                            byteOffset: h,
                            byteLength: b.byteLength,
                        }),
                        (h += b.byteLength),
                        a.images.push({
                            bufferView: I,
                            mimeType: "image/" + S,
                        }),
                        a.textures.push({ source: v }),
                        v
                    );
                }
            });
            let d = l.byteLength;
            for (let T = 0; T < u.length; T++) d += u[T].byteLength;
            let c = r(d);
            a.buffers.push({ byteLength: c });
            let p = JSON.stringify(a),
                m = vt(p),
                x = m.byteLength,
                g = r(x),
                C = 12 + 8 + g + 8 + c,
                E = new Pe(C, !0);
            E.WriteUnsignedInteger32(1179937895),
                E.WriteUnsignedInteger32(2),
                E.WriteUnsignedInteger32(C),
                E.WriteUnsignedInteger32(g),
                E.WriteUnsignedInteger32(1313821514),
                E.WriteArrayBuffer(m),
                i(E, 32, g - x),
                E.WriteUnsignedInteger32(c),
                E.WriteUnsignedInteger32(5130562),
                E.WriteArrayBuffer(l);
            for (let T = 0; T < u.length; T++) {
                let M = u[T];
                E.WriteArrayBuffer(M);
            }
            i(E, 0, c - d), n.SetBufferContent(E.GetBuffer());
        }
        GetMeshData(e) {
            let t = [];
            return (
                e.EnumerateTransformedMeshes((r) => {
                    let i = ot(r);
                    t.push({
                        name: r.GetName(),
                        buffer: i,
                        offsets: [],
                        sizes: [],
                    });
                }),
                t
            );
        }
        GetMainBuffer(e) {
            let t = 0;
            for (let i = 0; i < e.length; i++)
                t += e[i].buffer.GetByteLength(
                    this.components.index.size,
                    this.components.number.size
                );
            let r = new Pe(t, !0);
            for (let i = 0; i < e.length; i++) {
                let n = e[i];
                for (let o = 0; o < n.buffer.PrimitiveCount(); o++) {
                    let l = n.buffer.GetPrimitive(o),
                        a = r.GetPosition();
                    for (let u = 0; u < l.indices.length; u++)
                        r.WriteUnsignedInteger32(l.indices[u]);
                    for (let u = 0; u < l.vertices.length; u++)
                        r.WriteFloat32(l.vertices[u]);
                    for (let u = 0; u < l.colors.length; u++)
                        r.WriteFloat32(Ue(l.colors[u]));
                    for (let u = 0; u < l.normals.length; u++)
                        r.WriteFloat32(l.normals[u]);
                    for (let u = 0; u < l.uvs.length; u++) {
                        let h = l.uvs[u];
                        u % 2 === 1 && (h *= -1), r.WriteFloat32(h);
                    }
                    n.offsets.push(a), n.sizes.push(r.GetPosition() - a);
                }
            }
            return r.GetBuffer();
        }
        GetMainJson(e) {
            class t {
                constructor(n, o) {
                    (this.mainJson = n), (this.byteOffset = o);
                }
                AddBufferView(n) {
                    return (
                        this.mainJson.bufferViews.push({
                            buffer: 0,
                            byteOffset: this.byteOffset,
                            byteLength: n,
                        }),
                        (this.byteOffset += n),
                        this.mainJson.bufferViews.length - 1
                    );
                }
            }
            let r = {
                asset: { generator: "https://3dviewer.net", version: "2.0" },
                scene: 0,
                scenes: [{ nodes: [] }],
                nodes: [],
                materials: [],
                meshes: [],
                buffers: [],
                bufferViews: [],
                accessors: [],
            };
            for (let i = 0; i < e.length; i++) {
                let n = e[i];
                r.scenes[0].nodes.push(i), r.nodes.push({ mesh: i });
                let o = {
                        name: this.GetExportedMeshName(n.name),
                        primitives: [],
                    },
                    l = n.buffer.primitives;
                for (let a = 0; a < l.length; a++) {
                    let u = l[a],
                        h = new t(r, n.offsets[a]),
                        f = h.AddBufferView(
                            u.indices.length * this.components.index.size
                        ),
                        d = h.AddBufferView(
                            u.vertices.length * this.components.number.size
                        ),
                        c = null;
                    u.colors.length > 0 &&
                        (c = h.AddBufferView(
                            u.colors.length * this.components.number.size
                        ));
                    let p = h.AddBufferView(
                            u.normals.length * this.components.number.size
                        ),
                        m = null;
                    u.uvs.length > 0 &&
                        (m = h.AddBufferView(
                            u.uvs.length * this.components.number.size
                        ));
                    let x = { attributes: {}, mode: 4, material: u.material },
                        g = u.GetBounds();
                    r.accessors.push({
                        bufferView: f,
                        byteOffset: 0,
                        componentType: this.components.index.type,
                        count: u.indices.length,
                        type: "SCALAR",
                    }),
                        (x.indices = r.accessors.length - 1),
                        r.accessors.push({
                            bufferView: d,
                            byteOffset: 0,
                            componentType: this.components.number.type,
                            count: u.vertices.length / 3,
                            min: g.min,
                            max: g.max,
                            type: "VEC3",
                        }),
                        (x.attributes.POSITION = r.accessors.length - 1),
                        c !== null &&
                            (r.accessors.push({
                                bufferView: c,
                                byteOffset: 0,
                                componentType: this.components.number.type,
                                count: u.colors.length / 3,
                                type: "VEC3",
                            }),
                            (x.attributes.COLOR_0 = r.accessors.length - 1)),
                        r.accessors.push({
                            bufferView: p,
                            byteOffset: 0,
                            componentType: this.components.number.type,
                            count: u.normals.length / 3,
                            type: "VEC3",
                        }),
                        (x.attributes.NORMAL = r.accessors.length - 1),
                        m !== null &&
                            (r.accessors.push({
                                bufferView: m,
                                byteOffset: 0,
                                componentType: this.components.number.type,
                                count: u.uvs.length / 2,
                                type: "VEC2",
                            }),
                            (x.attributes.TEXCOORD_0 = r.accessors.length - 1)),
                        o.primitives.push(x);
                }
                r.meshes.push(o);
            }
            return r;
        }
        ExportMaterials(e, t, r) {
            function i(n, o, l, a) {
                function u(x, g) {
                    return [Ue(x.r / 255), Ue(x.g / 255), Ue(x.b / 255), g];
                }
                function h(x) {
                    return [Ue(x.r / 255), Ue(x.g / 255), Ue(x.b / 255)];
                }
                function f(x, g, C) {
                    if (g === null || !g.IsValid()) return null;
                    x.images === void 0 && (x.images = []),
                        x.textures === void 0 && (x.textures = []);
                    let T = { index: C(g) };
                    if (g.HasTransformation()) {
                        let M = "KHR_texture_transform";
                        x.extensionsUsed === void 0 && (x.extensionsUsed = []),
                            x.extensionsUsed.indexOf(M) === -1 &&
                                x.extensionsUsed.push(M),
                            (T.extensions = {
                                KHR_texture_transform: {
                                    offset: [g.offset.x, -g.offset.y],
                                    scale: [g.scale.x, g.scale.y],
                                    rotation: -g.rotation,
                                },
                            });
                    }
                    return T;
                }
                let d = {
                    name: n.GetExportedMaterialName(l.name),
                    pbrMetallicRoughness: {
                        baseColorFactor: u(l.color, l.opacity),
                    },
                    emissiveFactor: h(l.emissive),
                    doubleSided: !0,
                    alphaMode: "OPAQUE",
                };
                l.transparent && (d.alphaMode = "BLEND");
                let c = f(o, l.diffuseMap, a);
                if (
                    (c !== null &&
                        (l.multiplyDiffuseMap ||
                            (d.pbrMetallicRoughness.baseColorFactor = u(
                                new R(255, 255, 255),
                                l.opacity
                            )),
                        (d.pbrMetallicRoughness.baseColorTexture = c)),
                    l.type === se.Physical)
                ) {
                    let x = f(o, l.metalnessMap, a);
                    x !== null
                        ? (d.pbrMetallicRoughness.metallicRoughnessTexture = x)
                        : ((d.pbrMetallicRoughness.metallicFactor =
                              l.metalness),
                          (d.pbrMetallicRoughness.roughnessFactor =
                              l.roughness));
                }
                let p = f(o, l.normalMap, a);
                p !== null && (d.normalTexture = p);
                let m = f(o, l.emissiveMap, a);
                m !== null && (d.emissiveTexture = m), o.materials.push(d);
            }
            for (let n = 0; n < e.MaterialCount(); n++) {
                let o = e.GetMaterial(n);
                i(this, t, o, r);
            }
        }
    };
    var nr = class extends te {
        constructor() {
            super(), (this.rhino = null);
        }
        CanExport(e, t) {
            return e === B.Binary && t === "3dm";
        }
        ExportContent(e, t, r, i) {
            this.rhino === null
                ? pe("loaders/rhino3dm.min.js")
                      .then(() => {
                          rhino3dm().then((n) => {
                              (this.rhino = n),
                                  this.ExportRhinoContent(e, r, i);
                          });
                      })
                      .catch(() => {
                          i();
                      })
                : this.ExportRhinoContent(e, r, i);
        }
        ExportRhinoContent(e, t, r) {
            function i(u) {
                return { r: u.r, g: u.g, b: u.b, a: 255 };
            }
            let n = new j("model.3dm");
            t.push(n);
            let o = new this.rhino.File3dm();
            e.EnumerateTransformedMeshes((u) => {
                let h = ot(u);
                for (let f = 0; f < h.PrimitiveCount(); f++) {
                    let d = h.GetPrimitive(f),
                        c = {
                            data: {
                                attributes: {
                                    position: {
                                        itemSize: 3,
                                        type: "Float32Array",
                                        array: d.vertices,
                                    },
                                    normal: {
                                        itemSize: 3,
                                        type: "Float32Array",
                                        array: d.normals,
                                    },
                                },
                                index: {
                                    type: "Uint16Array",
                                    array: d.indices,
                                },
                            },
                        },
                        p = e.GetMaterial(d.material),
                        m = new this.rhino.Material();
                    (m.name = this.GetExportedMaterialName(p.name)),
                        p.type === se.Phong &&
                            ((m.ambientColor = i(p.ambient)),
                            (m.specularColor = i(p.specular))),
                        (m.diffuseColor = i(p.color)),
                        (m.transparency = 1 - p.opacity);
                    let x = o.materials().count();
                    o.materials().add(m);
                    let g = new this.rhino.Mesh.createFromThreejsJSON(c),
                        C = new this.rhino.ObjectAttributes();
                    (C.name = this.GetExportedMeshName(u.GetName())),
                        (C.materialSource =
                            this.rhino.ObjectMaterialSource.MaterialFromObject),
                        (C.materialIndex = x),
                        o.objects().add(g, C);
                }
            });
            let l = new this.rhino.File3dmWriteOptions();
            l.version = 6;
            let a = o.toByteArray(l);
            n.SetBufferContent(a), r();
        }
    };
    function qn() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
            let t = (Math.random() * 16) | 0;
            return (e === "x" ? t : (t & 3) | 8).toString(16);
        });
    }
    var or = class extends te {
        constructor() {
            super();
        }
        CanExport(e, t) {
            return e === B.Text && t === "bim";
        }
        ExportContent(e, t, r, i) {
            let n = { schema_version: "1.0.0", meshes: [], elements: [] };
            this.ExportProperties(e.GetModel(), n);
            let o = 0;
            e.EnumerateTransformedMeshes((a) => {
                let u = ot(a);
                for (let h = 0; h < u.PrimitiveCount(); h++) {
                    let f = u.GetPrimitive(h),
                        d = e.GetMaterial(f.material),
                        c = {
                            mesh_id: o,
                            coordinates: f.vertices,
                            indices: f.indices,
                        },
                        p = {
                            mesh_id: o,
                            type: "Other",
                            color: {
                                r: d.color.r,
                                g: d.color.g,
                                b: d.color.b,
                                a: he(d.opacity),
                            },
                            vector: { x: 0, y: 0, z: 0 },
                            rotation: { qx: 0, qy: 0, qz: 0, qw: 1 },
                            guid: qn(),
                        };
                    this.ExportProperties(a, p),
                        n.meshes.push(c),
                        n.elements.push(p),
                        (o += 1);
                }
            });
            let l = new j("model.bim");
            l.SetTextContent(JSON.stringify(n, null, 4)), r.push(l), i();
        }
        ExportProperties(e, t) {
            let r = {};
            for (let i = 0; i < e.PropertyGroupCount(); i++) {
                let n = e.GetPropertyGroup(i);
                for (let o = 0; o < n.PropertyCount(); o++) {
                    let l = n.GetProperty(o);
                    r[l.name] = fi(l);
                }
            }
            t.info = r;
        }
    };
    var Or = class {
            constructor(e) {
                (this.transformation = new H()),
                    (this.isMeshVisible = (t) => !0),
                    Rt(e, this);
            }
        },
        sr = class {
            constructor(e, t) {
                (this.model = e), (this.settings = t || new Or());
            }
            GetModel() {
                return this.model;
            }
            MaterialCount() {
                return this.model.MaterialCount();
            }
            GetMaterial(e) {
                return this.model.GetMaterial(e);
            }
            VertexCount() {
                let e = 0;
                return (
                    this.EnumerateMeshInstances((t) => {
                        e += t.VertexCount();
                    }),
                    e
                );
            }
            TriangleCount() {
                let e = 0;
                return (
                    this.EnumerateMeshInstances((t) => {
                        e += t.TriangleCount();
                    }),
                    e
                );
            }
            MeshInstanceCount() {
                let e = 0;
                return (
                    this.EnumerateMeshInstances((t) => {
                        e += 1;
                    }),
                    e
                );
            }
            EnumerateMeshInstances(e) {
                this.model.EnumerateMeshInstances((t) => {
                    this.settings.isMeshVisible(t.GetId()) && e(t);
                });
            }
            EnumerateTransformedMeshes(e) {
                this.EnumerateMeshInstances((t) => {
                    let r = t.GetTransformation();
                    this.settings.transformation.IsIdentity() ||
                        r.Append(this.settings.transformation);
                    let n = t.GetMesh().Clone();
                    r.IsIdentity() || Be(n, r), e(n);
                });
            }
            EnumerateVerticesAndTriangles(e) {
                let t = [];
                this.EnumerateTransformedMeshes((i) => {
                    t.push(i);
                });
                for (let i of t)
                    i.EnumerateVertices((n) => {
                        e.onVertex(n.x, n.y, n.z);
                    });
                let r = 0;
                for (let i of t)
                    i.EnumerateTriangleVertexIndices((n, o, l) => {
                        e.onTriangle(n + r, o + r, l + r);
                    }),
                        (r += i.VertexCount());
            }
            EnumerateTrianglesWithNormals(e) {
                this.EnumerateTransformedMeshes((t) => {
                    t.EnumerateTriangleVertices((r, i, n) => {
                        let o = ht(r, i, n);
                        e(r, i, n, o);
                    });
                });
            }
        };
    var Ce = class {
        constructor() {
            (this.text = ""), (this.indentation = 0);
        }
        GetText() {
            return this.text;
        }
        Indent(e) {
            this.indentation += e;
        }
        WriteArrayLine(e) {
            this.WriteLine(e.join(" "));
        }
        WriteLine(e) {
            this.WriteIndentation(),
                this.Write(
                    e +
                        `
`
                );
        }
        WriteIndentation() {
            for (let e = 0; e < this.indentation; e++) this.Write("  ");
        }
        Write(e) {
            this.text += e;
        }
    };
    var lr = class extends te {
        constructor() {
            super();
        }
        CanExport(e, t) {
            return e === B.Text && t === "obj";
        }
        ExportContent(e, t, r, i) {
            function n(p, m, x, g) {
                if (x === null || !x.IsValid()) return;
                let C = ee(x.name);
                if (
                    (p.WriteArrayLine([m, C]),
                    g.findIndex((T) => T.GetName() === C) === -1)
                ) {
                    let T = new j(C);
                    T.SetBufferContent(x.buffer), g.push(T);
                }
            }
            let o = new j("model.mtl"),
                l = new j("model.obj");
            r.push(o), r.push(l);
            let a = new Ce();
            a.WriteLine(this.GetHeaderText());
            for (let p = 0; p < e.MaterialCount(); p++) {
                let m = e.GetMaterial(p);
                a.WriteArrayLine([
                    "newmtl",
                    this.GetExportedMaterialName(m.name),
                ]),
                    a.WriteArrayLine([
                        "Kd",
                        m.color.r / 255,
                        m.color.g / 255,
                        m.color.b / 255,
                    ]),
                    a.WriteArrayLine(["d", m.opacity]),
                    m.type === se.Phong &&
                        (a.WriteArrayLine([
                            "Ka",
                            m.ambient.r / 255,
                            m.ambient.g / 255,
                            m.ambient.b / 255,
                        ]),
                        a.WriteArrayLine([
                            "Ks",
                            m.specular.r / 255,
                            m.specular.g / 255,
                            m.specular.b / 255,
                        ]),
                        a.WriteArrayLine(["Ns", m.shininess * 1e3])),
                    n(a, "map_Kd", m.diffuseMap, r),
                    m.type === se.Phong && n(a, "map_Ks", m.specularMap, r),
                    n(a, "bump", m.bumpMap, r);
            }
            o.SetTextContent(a.GetText());
            let u = new Ce();
            u.WriteLine(this.GetHeaderText()),
                u.WriteArrayLine(["mtllib", o.GetName()]);
            let h = 0,
                f = 0,
                d = 0,
                c = null;
            e.EnumerateTransformedMeshes((p) => {
                u.WriteArrayLine(["g", this.GetExportedMeshName(p.GetName())]);
                for (let m = 0; m < p.VertexCount(); m++) {
                    let x = p.GetVertex(m);
                    u.WriteArrayLine(["v", x.x, x.y, x.z]);
                }
                for (let m = 0; m < p.NormalCount(); m++) {
                    let x = p.GetNormal(m);
                    u.WriteArrayLine(["vn", x.x, x.y, x.z]);
                }
                for (let m = 0; m < p.TextureUVCount(); m++) {
                    let x = p.GetTextureUV(m);
                    u.WriteArrayLine(["vt", x.x, x.y]);
                }
                for (let m = 0; m < p.TriangleCount(); m++) {
                    let x = p.GetTriangle(m),
                        g = x.v0 + h + 1,
                        C = x.v1 + h + 1,
                        E = x.v2 + h + 1,
                        T = x.n0 + f + 1,
                        M = x.n1 + f + 1,
                        S = x.n2 + f + 1;
                    if (x.mat !== null) {
                        let G = e.GetMaterial(x.mat),
                            P = this.GetExportedMaterialName(G.name);
                        P !== c && (u.WriteArrayLine(["usemtl", P]), (c = P));
                    }
                    let I = "",
                        v = "",
                        b = "";
                    x.HasTextureUVs() &&
                        ((I = x.u0 + d + 1),
                        (v = x.u1 + d + 1),
                        (b = x.u2 + d + 1)),
                        u.WriteArrayLine([
                            "f",
                            [g, I, T].join("/"),
                            [C, v, M].join("/"),
                            [E, b, S].join("/"),
                        ]);
                }
                (h += p.VertexCount()),
                    (f += p.NormalCount()),
                    (d += p.TextureUVCount());
            }),
                l.SetTextContent(u.GetText()),
                i();
        }
        GetHeaderText() {
            return "# exported by https://3dviewer.net";
        }
    };
    var ar = class extends te {
        constructor() {
            super();
        }
        CanExport(e, t) {
            return e === B.Text && t === "off";
        }
        ExportContent(e, t, r, i) {
            let n = new j("model.off");
            r.push(n);
            let o = new Ce();
            o.WriteLine("OFF"),
                o.WriteArrayLine([e.VertexCount(), e.TriangleCount(), 0]),
                e.EnumerateVerticesAndTriangles({
                    onVertex: function (l, a, u) {
                        o.WriteArrayLine([l, a, u]);
                    },
                    onTriangle: function (l, a, u) {
                        o.WriteArrayLine([3, l, a, u]);
                    },
                }),
                n.SetTextContent(o.GetText()),
                i();
        }
    };
    var ur = class extends te {
        constructor() {
            super();
        }
        CanExport(e, t) {
            return (e === B.Text || e === B.Binary) && t === "ply";
        }
        ExportContent(e, t, r, i) {
            t === B.Text ? this.ExportText(e, r) : this.ExportBinary(e, r), i();
        }
        ExportText(e, t) {
            let r = new j("model.ply");
            t.push(r);
            let i = new Ce(),
                n = e.VertexCount(),
                o = e.TriangleCount(),
                l = this.GetHeaderText("ascii", n, o);
            i.Write(l),
                e.EnumerateVerticesAndTriangles({
                    onVertex: function (a, u, h) {
                        i.WriteArrayLine([a, u, h]);
                    },
                    onTriangle: function (a, u, h) {
                        i.WriteArrayLine([3, a, u, h]);
                    },
                }),
                r.SetTextContent(i.GetText());
        }
        ExportBinary(e, t) {
            let r = new j("model.ply");
            t.push(r);
            let i = e.VertexCount(),
                n = e.TriangleCount(),
                o = this.GetHeaderText("binary_little_endian", i, n),
                l = o.length + i * 3 * 4 + n * (1 + 3 * 4),
                a = new Pe(l, !0);
            for (let u = 0; u < o.length; u++)
                a.WriteUnsignedCharacter8(o.charCodeAt(u));
            e.EnumerateVerticesAndTriangles({
                onVertex: function (u, h, f) {
                    a.WriteFloat32(u), a.WriteFloat32(h), a.WriteFloat32(f);
                },
                onTriangle: function (u, h, f) {
                    a.WriteUnsignedCharacter8(3),
                        a.WriteInteger32(u),
                        a.WriteInteger32(h),
                        a.WriteInteger32(f);
                },
            }),
                r.SetBufferContent(a.GetBuffer());
        }
        GetHeaderText(e, t, r) {
            let i = new Ce();
            return (
                i.WriteLine("ply"),
                i.WriteLine("format " + e + " 1.0"),
                i.WriteLine("element vertex " + t),
                i.WriteLine("property float x"),
                i.WriteLine("property float y"),
                i.WriteLine("property float z"),
                i.WriteLine("element face " + r),
                i.WriteLine("property list uchar int vertex_index"),
                i.WriteLine("end_header"),
                i.GetText()
            );
        }
    };
    var hr = class extends te {
        constructor() {
            super();
        }
        CanExport(e, t) {
            return (e === B.Text || e === B.Binary) && t === "stl";
        }
        ExportContent(e, t, r, i) {
            t === B.Text ? this.ExportText(e, r) : this.ExportBinary(e, r), i();
        }
        ExportText(e, t) {
            let r = new j("model.stl");
            t.push(r);
            let i = new Ce();
            i.WriteLine("solid Model"),
                e.EnumerateTrianglesWithNormals((n, o, l, a) => {
                    i.WriteArrayLine(["facet", "normal", a.x, a.y, a.z]),
                        i.Indent(1),
                        i.WriteLine("outer loop"),
                        i.Indent(1),
                        i.WriteArrayLine(["vertex", n.x, n.y, n.z]),
                        i.WriteArrayLine(["vertex", o.x, o.y, o.z]),
                        i.WriteArrayLine(["vertex", l.x, l.y, l.z]),
                        i.Indent(-1),
                        i.WriteLine("endloop"),
                        i.Indent(-1),
                        i.WriteLine("endfacet");
                }),
                i.WriteLine("endsolid Model"),
                r.SetTextContent(i.GetText());
        }
        ExportBinary(e, t) {
            let r = new j("model.stl");
            t.push(r);
            let i = e.TriangleCount(),
                n = 80,
                o = n + 4 + i * 50,
                l = new Pe(o, !0);
            for (let a = 0; a < n; a++) l.WriteUnsignedCharacter8(0);
            l.WriteUnsignedInteger32(i),
                e.EnumerateTrianglesWithNormals((a, u, h, f) => {
                    l.WriteFloat32(f.x),
                        l.WriteFloat32(f.y),
                        l.WriteFloat32(f.z),
                        l.WriteFloat32(a.x),
                        l.WriteFloat32(a.y),
                        l.WriteFloat32(a.z),
                        l.WriteFloat32(u.x),
                        l.WriteFloat32(u.y),
                        l.WriteFloat32(u.z),
                        l.WriteFloat32(h.x),
                        l.WriteFloat32(h.y),
                        l.WriteFloat32(h.z),
                        l.WriteUnsignedInteger16(0);
                }),
                r.SetBufferContent(l.GetBuffer());
        }
    };
    var yi = class {
        constructor() {
            this.exporters = [
                new lr(),
                new hr(),
                new ur(),
                new ar(),
                new ir(),
                new nr(),
                new or(),
            ];
        }
        AddExporter(e) {
            this.exporters.push(e);
        }
        Export(e, t, r, i, n) {
            let o = null;
            for (let a = 0; a < this.exporters.length; a++) {
                let u = this.exporters[a];
                if (u.CanExport(r, i)) {
                    o = u;
                    break;
                }
            }
            if (o === null) {
                n.onError();
                return;
            }
            let l = new sr(e, t);
            o.Export(l, r, (a) => {
                a.length === 0 ? n.onError() : n.onSuccess(a);
            });
        }
    };
    var fr = class {
            constructor() {
                this.forceMediumpForMaterials = !1;
            }
        },
        dr = class {
            constructor() {
                (this.defaultMaterial = null), (this.objectUrls = []);
            }
        },
        Lr = class {
            constructor(e) {
                (this.callbacks = e),
                    (this.texturesNeeded = 0),
                    (this.texturesLoaded = 0),
                    (this.threeObject = null);
            }
            OnTextureNeeded() {
                this.texturesNeeded += 1;
            }
            OnTextureLoaded() {
                (this.texturesLoaded += 1),
                    this.callbacks.onTextureLoaded(),
                    this.Finish();
            }
            OnModelLoaded(e) {
                (this.threeObject = e), this.Finish();
            }
            Finish() {
                this.threeObject !== null &&
                    this.texturesNeeded === this.texturesLoaded &&
                    this.callbacks.onModelLoaded(this.threeObject);
            }
        },
        Br = class {
            constructor(e, t) {
                (this.meshInstances = []), this.AddNode(e, t);
            }
            AddNode(e, t) {
                let r = e.GetTransformation().GetMatrix(),
                    i = new THREE.Matrix4().fromArray(r.Get());
                t.applyMatrix4(i);
                for (let n of e.GetChildNodes()) {
                    let o = new THREE.Object3D();
                    t.add(o), this.AddNode(n, o);
                }
                for (let n of e.GetMeshIndices())
                    this.meshInstances.push({
                        node: e,
                        threeNode: t,
                        meshIndex: n,
                    });
            }
            GetMeshInstances() {
                return this.meshInstances;
            }
        };
    function Ii(s, e, t, r) {
        function i(d, c, p, m, x, g) {
            function C(b, G) {
                (G.wrapS = THREE.RepeatWrapping),
                    (G.wrapT = THREE.RepeatWrapping),
                    (G.rotation = b.rotation),
                    (G.offset.x = b.offset.x),
                    (G.offset.y = b.offset.y),
                    (G.repeat.x = b.scale.x),
                    (G.repeat.y = b.scale.y);
            }
            function E(b, G, P, N, D) {
                if (P === null || !P.IsValid()) return;
                let V = new THREE.TextureLoader();
                b.OnTextureNeeded();
                let Y = null;
                P.mimeType !== null
                    ? (Y = Zr(P.buffer, P.mimeType))
                    : (Y = ut(P.buffer)),
                    N.objectUrls.push(Y),
                    V.load(
                        Y,
                        (O) => {
                            C(P, O),
                                (G.needsUpdate = !0),
                                D(O),
                                b.OnTextureLoaded();
                        },
                        null,
                        (O) => {
                            b.OnTextureLoaded();
                        }
                    );
            }
            let T = c.GetMaterial(p),
                M = xe(T.color);
            T.vertexColors && M.setRGB(1, 1, 1);
            let S = {
                color: M,
                vertexColors: T.vertexColors,
                opacity: T.opacity,
                transparent: T.transparent,
                alphaTest: T.alphaTest,
                side: THREE.DoubleSide,
            };
            x.forceMediumpForMaterials && (S.precision = "mediump");
            let I = null;
            if (m === fe.Phong) {
                if (
                    ((I = new THREE.MeshPhongMaterial(S)), T.type === se.Phong)
                ) {
                    let b = xe(T.specular);
                    U(T.shininess, 0) && b.setRGB(0, 0, 0),
                        (I.specular = b),
                        (I.shininess = T.shininess * 100),
                        E(d, I, T.specularMap, g, (G) => {
                            I.specularMap = G;
                        });
                }
            } else
                m === fe.Physical &&
                    ((I = new THREE.MeshStandardMaterial(S)),
                    T.type === se.Physical &&
                        ((I.metalness = T.metalness),
                        (I.roughness = T.roughness),
                        E(d, I, T.metalnessMap, g, (b) => {
                            (I.metalness = 1),
                                (I.roughness = 1),
                                (I.metalnessMap = b),
                                (I.roughnessMap = b);
                        })));
            let v = xe(T.emissive);
            return (
                (I.emissive = v),
                E(d, I, T.diffuseMap, g, (b) => {
                    T.multiplyDiffuseMap || I.color.setRGB(1, 1, 1),
                        (I.map = b);
                }),
                E(d, I, T.bumpMap, g, (b) => {
                    I.bumpMap = b;
                }),
                E(d, I, T.normalMap, g, (b) => {
                    I.normalMap = b;
                }),
                E(d, I, T.emissiveMap, g, (b) => {
                    I.emissiveMap = b;
                }),
                T.isDefault && (g.defaultMaterial = I),
                I
            );
        }
        function n(d, c, p) {
            let m = d.GetMesh(c.meshIndex),
                x = m.TriangleCount(),
                g = [];
            for (let V = 0; V < x; V++) g.push(V);
            g.sort((V, Y) => {
                let O = m.GetTriangle(V),
                    Te = m.GetTriangle(Y);
                return O.mat - Te.mat;
            });
            let C = new THREE.BufferGeometry(),
                E = [],
                T = [],
                M = new Map(),
                S = [],
                I = [],
                v = [],
                b = [],
                G = [];
            G.push({ start: 0, end: -1 });
            let P = m.VertexColorCount() > 0,
                N = m.TextureUVCount() > 0;
            for (let V = 0; V < g.length; V++) {
                let Y = g[V],
                    O = m.GetTriangle(Y),
                    Te = m.GetVertex(O.v0),
                    Ve = m.GetVertex(O.v1),
                    Xr = m.GetVertex(O.v2);
                if (
                    (S.push(
                        Te.x,
                        Te.y,
                        Te.z,
                        Ve.x,
                        Ve.y,
                        Ve.z,
                        Xr.x,
                        Xr.y,
                        Xr.z
                    ),
                    O.HasVertexColors())
                ) {
                    let W = xe(m.GetVertexColor(O.c0)),
                        It = xe(m.GetVertexColor(O.c1)),
                        Et = xe(m.GetVertexColor(O.c2));
                    I.push(W.r, W.g, W.b, It.r, It.g, It.b, Et.r, Et.g, Et.b);
                } else P && I.push(0, 0, 0, 0, 0, 0, 0, 0, 0);
                let Tt = m.GetNormal(O.n0),
                    yt = m.GetNormal(O.n1),
                    st = m.GetNormal(O.n2);
                if (
                    (v.push(
                        Tt.x,
                        Tt.y,
                        Tt.z,
                        yt.x,
                        yt.y,
                        yt.z,
                        st.x,
                        st.y,
                        st.z
                    ),
                    O.HasTextureUVs())
                ) {
                    let W = m.GetTextureUV(O.u0),
                        It = m.GetTextureUV(O.u1),
                        Et = m.GetTextureUV(O.u2);
                    b.push(W.x, W.y, It.x, It.y, Et.x, Et.y);
                } else N && b.push(0, 0, 0, 0, 0, 0);
                let ie = O.mat;
                M.has(ie) ||
                    (M.set(ie, E.length),
                    E.push(p[ie]),
                    T.push(ie),
                    V > 0 &&
                        ((G[G.length - 1].end = V - 1),
                        G.push({ start: G[G.length - 1].end + 1, end: -1 })));
            }
            (G[G.length - 1].end = x - 1),
                C.setAttribute(
                    "position",
                    new THREE.Float32BufferAttribute(S, 3)
                ),
                I.length !== 0 &&
                    C.setAttribute(
                        "color",
                        new THREE.Float32BufferAttribute(I, 3)
                    ),
                C.setAttribute(
                    "normal",
                    new THREE.Float32BufferAttribute(v, 3)
                ),
                b.length !== 0 &&
                    C.setAttribute(
                        "uv",
                        new THREE.Float32BufferAttribute(b, 2)
                    );
            for (let V = 0; V < G.length; V++) {
                let Y = G[V];
                C.addGroup(Y.start * 3, (Y.end - Y.start + 1) * 3, V);
            }
            let D = new THREE.Mesh(C, E);
            return (
                (D.name = m.GetName()),
                (D.userData = {
                    originalMeshId: c,
                    originalMaterials: T,
                    threeMaterials: null,
                }),
                D
            );
        }
        function o(d, c, p, m) {
            let x = c.GetMesh(p.meshIndex);
            if (et(x) === Le.TriangleMesh) {
                let C = n(c, p, m);
                d.add(C);
            }
        }
        function l(d, c, p, m) {
            let x = c.GetRootNode(),
                C = new Br(x, d).GetMeshInstances();
            oi(C.length, 100, {
                runTask: (E, T, M) => {
                    for (let S = E; S <= T; S++) {
                        let I = C[S],
                            v = I.node,
                            b = I.threeNode,
                            G = new Xe(v.GetId(), I.meshIndex);
                        o(b, c, G, p);
                    }
                    M();
                },
                onReady: () => {
                    m.OnModelLoaded(d);
                },
            });
        }
        let a = new Lr(r),
            u = mi(s),
            h = [];
        for (let d = 0; d < s.MaterialCount(); d++) {
            let c = i(a, s, d, u, e, t);
            h.push(c);
        }
        let f = new THREE.Object3D();
        l(f, s, h, a);
    }
    var mr = class {
        constructor() {
            (this.importer = new rr()),
                (this.inProgress = !1),
                (this.defaultMaterial = null),
                (this.objectUrls = null),
                (this.hasHighpDriverIssue = di());
        }
        InProgress() {
            return this.inProgress;
        }
        LoadModel(e, t, r, i) {
            this.inProgress ||
                ((this.inProgress = !0),
                i.onLoadStart(),
                this.RevokeObjectUrls(),
                this.importer.ImportFiles(e, t, r, {
                    onFilesLoaded: () => {
                        i.onImportStart();
                    },
                    onSelectMainFile: (n, o) => {
                        i.onSelectMainFile ? i.onSelectMainFile(n, o) : o(0);
                    },
                    onImportSuccess: (n) => {
                        i.onVisualizationStart();
                        let o = new fr();
                        o.forceMediumpForMaterials = this.hasHighpDriverIssue;
                        let l = new dr();
                        Ii(n.model, o, l, {
                            onTextureLoaded: () => {
                                i.onTextureLoaded();
                            },
                            onModelLoaded: (a) => {
                                if (
                                    ((this.defaultMaterial = l.defaultMaterial),
                                    (this.objectUrls = l.objectUrls),
                                    n.upVector === w.X)
                                ) {
                                    let u =
                                        new THREE.Quaternion().setFromAxisAngle(
                                            new THREE.Vector3(0, 0, 1),
                                            Math.PI / 2
                                        );
                                    a.quaternion.multiply(u);
                                } else if (n.upVector === w.Z) {
                                    let u =
                                        new THREE.Quaternion().setFromAxisAngle(
                                            new THREE.Vector3(1, 0, 0),
                                            -Math.PI / 2
                                        );
                                    a.quaternion.multiply(u);
                                }
                                i.onModelFinished(n, a), (this.inProgress = !1);
                            },
                        });
                    },
                    onImportError: (n) => {
                        i.onLoadError(n), (this.inProgress = !1);
                    },
                }));
        }
        GetImporter() {
            return this.importer;
        }
        GetDefaultMaterial() {
            return this.defaultMaterial;
        }
        ReplaceDefaultMaterialColor(e) {
            this.defaultMaterial !== null &&
                !this.defaultMaterial.vertexColors &&
                (this.defaultMaterial.color = xe(e));
        }
        RevokeObjectUrls() {
            if (this.objectUrls !== null) {
                for (let e of this.objectUrls) Qr(e);
                this.objectUrls = null;
            }
        }
    };
    function Wi(s, e, t) {
        let r = Ie(s, e),
            i = Ie(e, t),
            n = Ie(s, t),
            o = (r + i + n) / 2,
            l = o * (o - r) * (o - i) * (o - n);
        return l < 0 ? 0 : Math.sqrt(l);
    }
    function qi(s, e, t) {
        return Tr(s, Ge(e, t)) / 6;
    }
    function In(s) {
        let e = 0;
        return (
            s.EnumerateTriangleVertices((t, r, i) => {
                e += qi(t, r, i);
            }),
            e
        );
    }
    function En(s) {
        let e = 0;
        return (
            s.EnumerateTriangleVertices((t, r, i) => {
                e += Wi(t, r, i);
            }),
            e
        );
    }
    function Mn(s, e, t) {
        let r = e / t;
        return s * (r * r * (3 - 2 * r));
    }
    function bn(s, e, t) {
        return (e * s) / t;
    }
    function Ei(s, e, t) {
        let r = e / t,
            i = r * r;
        return s * (i / (2 * (i - r) + 1));
    }
    function cr(s, e, t, r) {
        let i = ne(e, s).Normalize(),
            n = Ie(s, e),
            o = [];
        for (let l = 0; l < t; l++) {
            let a = r(n, l, t - 1);
            o.push(s.Clone().Offset(i, a));
        }
        return o;
    }
    function re(s) {
        return Math.round(parseFloat(s));
    }
    function Mi(s) {
        let e = re(s.paddingLeft) + re(s.paddingRight),
            t = re(s.borderLeftWidth) + re(s.borderRightWidth),
            r = re(s.marginLeft) + re(s.marginRight);
        return e + t + r;
    }
    function bi(s) {
        let e = re(s.paddingTop) + re(s.paddingBottom),
            t = re(s.borderTopWidth) + re(s.borderBottomWidth),
            r = re(s.marginTop) + re(s.marginBottom);
        return e + t + r;
    }
    function Si(s, e, t) {
        let r = getComputedStyle(s),
            i = e - Mi(r),
            n = t - bi(r);
        return { width: i, height: n };
    }
    function Ke(s, e, t) {
        if (s.getBoundingClientRect) {
            let r = s.getBoundingClientRect();
            (e -= r.left), (t -= r.top);
        }
        return (
            window.pageXOffset &&
                window.pageYOffset &&
                ((e += window.pageXOffset), (t += window.pageYOffset)),
            new F(e, t)
        );
    }
    function wi(s, e, t) {
        let r = document.createElement(s);
        return e && (r.className = e), t && (r.innerHTML = t), r;
    }
    function Xi(s, e, t, r) {
        let i = wi(e, t, r);
        return s.appendChild(i), i;
    }
    function Sn(s, e, t) {
        return Xi(s, "div", e, t);
    }
    function wn(s) {
        for (; s.firstChild; ) s.removeChild(s.firstChild);
    }
    function vn(s, e) {
        e.parentNode.insertBefore(s, e);
    }
    function An(s, e) {
        e.parentNode.insertBefore(s, e.nextSibling);
    }
    function Gn(s, e) {
        e ? (s.style.display = "block") : (s.style.display = "none");
    }
    function Rn(s) {
        return s.offsetParent !== null;
    }
    function Yi(s, e) {
        s.style.width = e.toString() + "px";
    }
    function Ji(s, e) {
        s.style.height = e.toString() + "px";
    }
    function Fn(s) {
        let e = getComputedStyle(s);
        return s.offsetWidth + re(e.marginLeft) + re(e.marginRight);
    }
    function Nn(s) {
        let e = getComputedStyle(s);
        return s.offsetHeight + re(e.marginTop) + re(e.marginBottom);
    }
    function Dn(s, e) {
        let t = getComputedStyle(s);
        Yi(s, e - Mi(t));
    }
    function Pn(s, e) {
        let t = getComputedStyle(s);
        Ji(s, e - bi(t));
    }
    function Vn(s, e) {
        return wi("div", s, e);
    }
    var Ae = class {
        constructor(e, t, r) {
            (this.eye = e), (this.center = t), (this.up = r);
        }
        Clone() {
            return new Ae(
                this.eye.Clone(),
                this.center.Clone(),
                this.up.Clone()
            );
        }
    };
    function vi(s, e) {
        return ye(s.eye, e.eye) && ye(s.center, e.center) && ye(s.up, e.up);
    }
    var Ur = class {
            constructor() {
                (this.prev = new F(0, 0)),
                    (this.curr = new F(0, 0)),
                    (this.diff = new F(0, 0)),
                    (this.buttons = []);
            }
            Down(e, t) {
                this.buttons.push(t.which),
                    (this.curr = this.GetPositionFromEvent(e, t)),
                    (this.prev = this.curr.Clone());
            }
            Move(e, t) {
                (this.curr = this.GetPositionFromEvent(e, t)),
                    (this.diff = Ir(this.curr, this.prev)),
                    (this.prev = this.curr.Clone());
            }
            Up(e, t) {
                let r = this.buttons.indexOf(t.which);
                r !== -1 && this.buttons.splice(r, 1),
                    (this.curr = this.GetPositionFromEvent(e, t));
            }
            Leave(e, t) {
                (this.buttons = []),
                    (this.curr = this.GetPositionFromEvent(e, t));
            }
            IsButtonDown() {
                return this.buttons.length > 0;
            }
            GetButton() {
                let e = this.buttons.length;
                return e === 0 ? 0 : this.buttons[e - 1];
            }
            GetPosition() {
                return this.curr;
            }
            GetMoveDiff() {
                return this.diff;
            }
            GetPositionFromEvent(e, t) {
                return Ke(e, t.clientX, t.clientY);
            }
        },
        zr = class {
            constructor() {
                (this.prevPos = new F(0, 0)),
                    (this.currPos = new F(0, 0)),
                    (this.diffPos = new F(0, 0)),
                    (this.prevDist = 0),
                    (this.currDist = 0),
                    (this.diffDist = 0),
                    (this.fingers = 0);
            }
            Start(e, t) {
                t.touches.length !== 0 &&
                    ((this.fingers = t.touches.length),
                    (this.currPos = this.GetPositionFromEvent(e, t)),
                    (this.prevPos = this.currPos.Clone()),
                    (this.currDist = this.GetTouchDistanceFromEvent(e, t)),
                    (this.prevDist = this.currDist));
            }
            Move(e, t) {
                t.touches.length !== 0 &&
                    ((this.currPos = this.GetPositionFromEvent(e, t)),
                    (this.diffPos = Ir(this.currPos, this.prevPos)),
                    (this.prevPos = this.currPos.Clone()),
                    (this.currDist = this.GetTouchDistanceFromEvent(e, t)),
                    (this.diffDist = this.currDist - this.prevDist),
                    (this.prevDist = this.currDist));
            }
            End(e, t) {
                t.touches.length !== 0 &&
                    ((this.fingers = 0),
                    (this.currPos = this.GetPositionFromEvent(e, t)),
                    (this.currDist = this.GetTouchDistanceFromEvent(e, t)));
            }
            IsFingerDown() {
                return this.fingers !== 0;
            }
            GetFingerCount() {
                return this.fingers;
            }
            GetPosition() {
                return this.currPos;
            }
            GetMoveDiff() {
                return this.diffPos;
            }
            GetDistanceDiff() {
                return this.diffDist;
            }
            GetPositionFromEvent(e, t) {
                let r = null;
                if (t.touches.length !== 0) {
                    let i = t.touches[0];
                    r = Ke(e, i.pageX, i.pageY);
                }
                return r;
            }
            GetTouchDistanceFromEvent(e, t) {
                if (t.touches.length !== 2) return 0;
                let r = t.touches[0],
                    i = t.touches[1];
                return Er(Ke(e, r.pageX, r.pageY), Ke(e, i.pageX, i.pageY));
            }
        },
        _r = class {
            constructor() {
                (this.isClick = !1), (this.startPosition = null);
            }
            Start(e) {
                (this.isClick = !0), (this.startPosition = e);
            }
            Move(e) {
                !this.isClick ||
                    (this.startPosition !== null
                        ? Er(this.startPosition, e) > 3 && this.Cancel()
                        : this.Cancel());
            }
            End() {
                this.startPosition = null;
            }
            Cancel() {
                (this.isClick = !1), (this.startPosition = null);
            }
            IsClick() {
                return this.isClick;
            }
        },
        me = { None: 0, Orbit: 1, Pan: 2, Zoom: 3 },
        pr = class {
            constructor(e, t, r) {
                (this.canvas = e),
                    (this.camera = t),
                    (this.callbacks = r),
                    (this.fixUpVector = !0),
                    (this.mouse = new Ur()),
                    (this.touch = new zr()),
                    (this.clickDetector = new _r()),
                    (this.onMouseClick = null),
                    (this.onMouseMove = null),
                    (this.onContext = null),
                    this.canvas.addEventListener &&
                        (this.canvas.addEventListener(
                            "mousedown",
                            this.OnMouseDown.bind(this)
                        ),
                        this.canvas.addEventListener(
                            "wheel",
                            this.OnMouseWheel.bind(this)
                        ),
                        this.canvas.addEventListener(
                            "touchstart",
                            this.OnTouchStart.bind(this)
                        ),
                        this.canvas.addEventListener(
                            "touchmove",
                            this.OnTouchMove.bind(this)
                        ),
                        this.canvas.addEventListener(
                            "touchcancel",
                            this.OnTouchEnd.bind(this)
                        ),
                        this.canvas.addEventListener(
                            "touchend",
                            this.OnTouchEnd.bind(this)
                        ),
                        this.canvas.addEventListener(
                            "contextmenu",
                            this.OnContextMenu.bind(this)
                        )),
                    document.addEventListener &&
                        (document.addEventListener(
                            "mousemove",
                            this.OnMouseMove.bind(this)
                        ),
                        document.addEventListener(
                            "mouseup",
                            this.OnMouseUp.bind(this)
                        ),
                        document.addEventListener(
                            "mouseleave",
                            this.OnMouseLeave.bind(this)
                        ));
            }
            SetMouseClickHandler(e) {
                this.onMouseClick = e;
            }
            SetMouseMoveHandler(e) {
                this.onMouseMove = e;
            }
            SetContextMenuHandler(e) {
                this.onContext = e;
            }
            IsFixUpVector() {
                return this.fixUpVector;
            }
            SetFixUpVector(e) {
                this.fixUpVector = e;
            }
            GetCamera() {
                return this.camera;
            }
            SetCamera(e) {
                this.camera = e;
            }
            MoveCamera(e, t) {
                function r(i, n, o, l) {
                    (i.camera.eye = n.eye[l]),
                        (i.camera.center = n.center[l]),
                        (i.camera.up = n.up[l]),
                        i.Update(),
                        l < o - 1 &&
                            requestAnimationFrame(() => {
                                r(i, n, o, l + 1);
                            });
                }
                if (e !== null) {
                    if (t === 0 || vi(this.camera, e)) this.camera = e;
                    else {
                        let i = Ei,
                            n = {
                                eye: cr(this.camera.eye, e.eye, t, i),
                                center: cr(this.camera.center, e.center, t, i),
                                up: cr(this.camera.up, e.up, t, i),
                            };
                        requestAnimationFrame(() => {
                            r(this, n, t, 0);
                        });
                    }
                    this.Update();
                }
            }
            GetFitToSphereCamera(e, t, r) {
                if (lt(t)) return null;
                let i = this.camera.Clone(),
                    n = ne(i.center, e);
                (i.eye = ne(i.eye, n)), (i.center = e.Clone());
                let o = ne(i.eye, i.center).Normalize(),
                    l = r / 2;
                this.canvas.width < this.canvas.height &&
                    (l = (l * this.canvas.width) / this.canvas.height);
                let a = t / Math.sin(l * Ze);
                return (i.eye = i.center.Clone().Offset(o, a)), i;
            }
            OnMouseDown(e) {
                e.preventDefault(),
                    this.mouse.Down(this.canvas, e),
                    this.clickDetector.Start(this.mouse.GetPosition());
            }
            OnMouseMove(e) {
                if (
                    (this.mouse.Move(this.canvas, e),
                    this.clickDetector.Move(this.mouse.GetPosition()),
                    this.onMouseMove)
                ) {
                    let n = Ke(this.canvas, e.clientX, e.clientY);
                    this.onMouseMove(n);
                }
                if (!this.mouse.IsButtonDown()) return;
                let t = this.mouse.GetMoveDiff(),
                    r = this.mouse.GetButton(),
                    i = me.None;
                if (
                    (r === 1
                        ? e.ctrlKey
                            ? (i = me.Zoom)
                            : e.shiftKey
                            ? (i = me.Pan)
                            : (i = me.Orbit)
                        : (r === 2 || r === 3) && (i = me.Pan),
                    i === me.Orbit)
                ) {
                    let n = 0.5;
                    this.Orbit(t.x * n, t.y * n);
                } else if (i === me.Pan) {
                    let n = Ie(this.camera.eye, this.camera.center),
                        o = 0.001 * n;
                    this.Pan(t.x * o, t.y * o);
                } else if (i === me.Zoom) {
                    let n = 0.005;
                    this.Zoom(-t.y * n);
                }
                this.Update();
            }
            OnMouseUp(e) {
                if (
                    (this.mouse.Up(this.canvas, e),
                    this.clickDetector.End(),
                    this.clickDetector.IsClick())
                ) {
                    let t = this.mouse.GetPosition();
                    this.Click(e.which, t);
                }
            }
            OnMouseLeave(e) {
                this.mouse.Leave(this.canvas, e), this.clickDetector.Cancel();
            }
            OnTouchStart(e) {
                e.preventDefault(),
                    this.touch.Start(this.canvas, e),
                    this.clickDetector.Start(this.touch.GetPosition());
            }
            OnTouchMove(e) {
                if (
                    (e.preventDefault(),
                    this.touch.Move(this.canvas, e),
                    this.clickDetector.Move(this.touch.GetPosition()),
                    !this.touch.IsFingerDown())
                )
                    return;
                let t = this.touch.GetMoveDiff(),
                    r = this.touch.GetDistanceDiff(),
                    i = this.touch.GetFingerCount(),
                    n = me.None;
                if (
                    (i === 1 ? (n = me.Orbit) : i === 2 && (n = me.Pan),
                    n === me.Orbit)
                ) {
                    let o = 0.5;
                    this.Orbit(t.x * o, t.y * o);
                } else if (n === me.Pan) {
                    let o = 0.005;
                    this.Zoom(r * o);
                    let l = 0.001 * Ie(this.camera.eye, this.camera.center);
                    this.Pan(t.x * l, t.y * l);
                }
                this.Update();
            }
            OnTouchEnd(e) {
                if (
                    (e.preventDefault(),
                    this.touch.End(this.canvas, e),
                    this.clickDetector.End(),
                    this.clickDetector.IsClick())
                ) {
                    let t = this.touch.GetPosition();
                    this.touch.GetFingerCount() === 1 && this.Click(1, t);
                }
            }
            OnMouseWheel(e) {
                let t = e || window.event;
                t.preventDefault();
                let r = -t.deltaY / 40,
                    i = 0.1;
                r < 0 && (i = i * -1), this.Zoom(i), this.Update();
            }
            OnContextMenu(e) {
                e.preventDefault(),
                    this.clickDetector.IsClick() &&
                        (this.Context(e.clientX, e.clientY),
                        this.clickDetector.Cancel());
            }
            Orbit(e, t) {
                let r = e * Ze,
                    i = t * Ze,
                    n = ne(this.camera.center, this.camera.eye).Normalize(),
                    o = Ge(n, this.camera.up).Normalize();
                if (this.fixUpVector) {
                    let a = Kr(n, this.camera.up) + i;
                    Yr(a, 0) &&
                        Mt(a, Math.PI) &&
                        this.camera.eye.Rotate(o, -i, this.camera.center),
                        this.camera.eye.Rotate(
                            this.camera.up,
                            -r,
                            this.camera.center
                        );
                } else {
                    let l = Ge(o, n).Normalize();
                    this.camera.eye.Rotate(o, -i, this.camera.center),
                        this.camera.eye.Rotate(l, -r, this.camera.center),
                        (this.camera.up = l);
                }
            }
            Pan(e, t) {
                let r = ne(this.camera.center, this.camera.eye).Normalize(),
                    i = Ge(r, this.camera.up).Normalize(),
                    n = Ge(i, r).Normalize();
                this.camera.eye.Offset(i, -e),
                    this.camera.center.Offset(i, -e),
                    this.camera.eye.Offset(n, t),
                    this.camera.center.Offset(n, t);
            }
            Zoom(e) {
                let t = ne(this.camera.center, this.camera.eye),
                    i = t.Length() * e;
                this.camera.eye.Offset(t, i);
            }
            Update() {
                this.callbacks.onUpdate();
            }
            Click(e, t) {
                this.onMouseClick && this.onMouseClick(e, t);
            }
            Context(e, t) {
                if (this.onContext) {
                    let r = { x: e, y: t },
                        i = Ke(this.canvas, e, t);
                    this.onContext(r, i);
                }
            }
        };
    function Ai(s, e) {
        function t(r, i) {
            for (let n of r)
                (n.polygonOffset = i),
                    (n.polygonOffsetUnit = 1),
                    (n.polygonOffsetFactor = 1);
        }
        t(s.material, e),
            s.userData.threeMaterials && t(s.userData.threeMaterials, e);
    }
    var xr = class {
            constructor(e) {
                (this.scene = e),
                    (this.mainObject = null),
                    (this.mainEdgeObject = null),
                    (this.edgeSettings = {
                        showEdges: !1,
                        edgeColor: new R(0, 0, 0),
                        edgeThreshold: 1,
                    });
            }
            SetMainObject(e) {
                (this.mainObject = e),
                    this.scene.add(this.mainObject),
                    this.edgeSettings.showEdges &&
                        this.GenerateMainEdgeObject();
            }
            UpdateWorldMatrix() {
                this.mainObject !== null &&
                    this.mainObject.updateWorldMatrix(!0, !0);
            }
            SetEdgeSettings(e, t, r) {
                let i = !1;
                if (
                    (e &&
                        (!this.edgeSettings.showEdges ||
                            this.edgeSettings.edgeThreshold !== r) &&
                        (i = !0),
                    (this.edgeSettings.showEdges = e),
                    (this.edgeSettings.edgeThreshold = r),
                    (this.edgeSettings.edgeColor = t),
                    this.mainObject !== null)
                )
                    if (this.edgeSettings.showEdges)
                        if (i)
                            this.ClearMainEdgeObject(),
                                this.GenerateMainEdgeObject();
                        else {
                            let n = xe(this.edgeSettings.edgeColor);
                            this.EnumerateEdges((o) => {
                                o.material.color = n;
                            });
                        }
                    else this.ClearMainEdgeObject();
            }
            GenerateMainEdgeObject() {
                let e = xe(this.edgeSettings.edgeColor);
                (this.mainEdgeObject = new THREE.Object3D()),
                    this.UpdateWorldMatrix(),
                    this.EnumerateMeshes((t) => {
                        Ai(t, !0);
                        let r = new THREE.EdgesGeometry(
                                t.geometry,
                                this.edgeSettings.edgeThreshold
                            ),
                            i = new THREE.LineSegments(
                                r,
                                new THREE.LineBasicMaterial({ color: e })
                            );
                        i.applyMatrix4(t.matrixWorld),
                            (i.userData = t.userData),
                            (i.visible = t.visible),
                            this.mainEdgeObject.add(i);
                    }),
                    this.scene.add(this.mainEdgeObject);
            }
            GetBoundingBox(e) {
                let t = !1,
                    r = new THREE.Box3();
                return (
                    this.EnumerateMeshes((i) => {
                        e(i.userData) &&
                            (r.union(new THREE.Box3().setFromObject(i)),
                            (t = !0));
                    }),
                    t ? r : null
                );
            }
            GetBoundingSphere(e) {
                let t = this.GetBoundingBox(e);
                if (t === null) return null;
                let r = new THREE.Sphere();
                return t.getBoundingSphere(r), r;
            }
            Clear() {
                this.ClearMainObject(), this.ClearMainEdgeObject();
            }
            ClearMainObject() {
                this.mainObject !== null &&
                    (this.EnumerateMeshes((e) => {
                        e.geometry.dispose();
                    }),
                    this.scene.remove(this.mainObject),
                    (this.mainObject = null));
            }
            ClearMainEdgeObject() {
                this.mainEdgeObject !== null &&
                    (this.EnumerateMeshes((e) => {
                        Ai(e, !1);
                    }),
                    this.EnumerateEdges((e) => {
                        e.geometry.dispose();
                    }),
                    this.scene.remove(this.mainEdgeObject),
                    (this.mainEdgeObject = null));
            }
            EnumerateMeshes(e) {
                this.mainObject !== null &&
                    this.mainObject.traverse((t) => {
                        t.isMesh && e(t);
                    });
            }
            EnumerateEdges(e) {
                this.mainEdgeObject !== null &&
                    this.mainEdgeObject.traverse((t) => {
                        t.isLineSegments && e(t);
                    });
            }
            GetMeshIntersectionUnderMouse(e, t, r, i) {
                if (
                    this.mainObject === null ||
                    e.x < 0 ||
                    e.x > r ||
                    e.y < 0 ||
                    e.y > i
                )
                    return null;
                let n = new THREE.Raycaster(),
                    o = new THREE.Vector2();
                (o.x = (e.x / r) * 2 - 1),
                    (o.y = -(e.y / i) * 2 + 1),
                    n.setFromCamera(o, t);
                let l = n.intersectObject(this.mainObject, !0);
                for (let a = 0; a < l.length; a++) {
                    let u = l[a];
                    if (u.object.type === "Mesh" && u.object.visible) return u;
                }
                return null;
            }
        },
        gr = class {
            constructor(e) {
                (this.scene = e), (this.mainObject = null);
            }
            AddObject(e) {
                this.mainObject === null &&
                    ((this.mainObject = new THREE.Object3D()),
                    this.scene.add(this.mainObject)),
                    this.mainObject.add(e);
            }
            Clear() {
                this.mainObject !== null &&
                    (this.mainObject.traverse((e) => {
                        (e.isMesh || e.isLineSegments) && e.geometry.dispose();
                    }),
                    this.scene.remove(this.mainObject),
                    (this.mainObject = null));
            }
        };
    function Gi(s) {
        return s === w.X
            ? new Ae(new y(2, -3, 1.5), new y(0, 0, 0), new y(1, 0, 0))
            : s === w.Y
            ? new Ae(new y(-1.5, 2, 3), new y(0, 0, 0), new y(0, 1, 0))
            : s === w.Z
            ? new Ae(new y(-1.5, -3, 2), new y(0, 0, 0), new y(0, 0, 1))
            : null;
    }
    function Ri(s, e) {
        if (!e(s)) return !1;
        for (let t of s.children) if (!Ri(t, e)) return !1;
        return !0;
    }
    function Ki(s) {
        let e = null;
        return (
            Ri(s, (t) => {
                if (t.isMesh)
                    for (let r of t.material)
                        return (
                            r.type === "MeshPhongMaterial"
                                ? (e = fe.Phong)
                                : r.type === "MeshStandardMaterial" &&
                                  (e = fe.Physical),
                            !1
                        );
                return !0;
            }),
            e
        );
    }
    var Hr = class {
            constructor() {
                (this.direction = w.Z),
                    (this.isFixed = !0),
                    (this.isFlipped = !1);
            }
            SetDirection(e, t) {
                (this.direction = e), (this.isFlipped = !1);
                let r = Gi(this.direction),
                    i = ne(r.eye, r.center),
                    n = Ie(t.center, t.eye),
                    o = t.center.Clone().Offset(i, n),
                    l = t.Clone();
                return (
                    this.direction === w.X
                        ? ((l.up = new y(1, 0, 0)), (l.eye = o))
                        : this.direction === w.Y
                        ? ((l.up = new y(0, 1, 0)), (l.eye = o))
                        : this.direction === w.Z &&
                          ((l.up = new y(0, 0, 1)), (l.eye = o)),
                    l
                );
            }
            SetFixed(e, t) {
                return (
                    (this.isFixed = e),
                    this.isFixed ? this.SetDirection(this.direction, t) : null
                );
            }
            Flip(e) {
                this.isFlipped = !this.isFlipped;
                let t = e.Clone();
                return t.up.MultiplyScalar(-1), t;
            }
        },
        kr = class {
            constructor(e) {
                (this.scene = e),
                    (this.type = fe.Phong),
                    (this.ambientLight = new THREE.AmbientLight(8947848)),
                    (this.directionalLight = new THREE.DirectionalLight(
                        8947848
                    )),
                    (this.environment = null),
                    (this.backgroundIsEnvMap = !1),
                    this.scene.add(this.ambientLight),
                    this.scene.add(this.directionalLight);
            }
            SetType(e) {
                (this.type = e), this.UpdateShading();
            }
            UpdateShading() {
                this.type === fe.Phong
                    ? (this.ambientLight.color.set(8947848),
                      this.directionalLight.color.set(8947848),
                      (this.scene.environment = null),
                      (this.scene.background = null))
                    : this.type === fe.Physical &&
                      (this.ambientLight.color.set(0),
                      this.directionalLight.color.set(5592405),
                      (this.scene.environment = this.environment),
                      this.backgroundIsEnvMap
                          ? (this.scene.background = this.environment)
                          : (this.scene.background = null));
            }
            SetEnvironment(e, t, r) {
                let i = new THREE.CubeTextureLoader();
                (this.environment = i.load(e, () => {
                    r();
                })),
                    (this.backgroundIsEnvMap = t);
            }
            UpdateByCamera(e) {
                let t = ne(e.eye, e.center);
                this.directionalLight.position.set(t.x, t.y, t.z);
            }
            CreateHighlightMaterial(e, t) {
                let r = null;
                return (
                    this.type === fe.Phong
                        ? (r = new THREE.MeshPhongMaterial({
                              color: e,
                              side: THREE.DoubleSide,
                          }))
                        : this.type === fe.Physical &&
                          (r = new THREE.MeshStandardMaterial({
                              color: e,
                              side: THREE.DoubleSide,
                          })),
                    r !== null &&
                        t &&
                        ((r.polygonOffset = !0),
                        (r.polygonOffsetUnit = 1),
                        (r.polygonOffsetFactor = 1)),
                    r
                );
            }
        },
        Cr = class {
            constructor() {
                (this.canvas = null),
                    (this.renderer = null),
                    (this.scene = null),
                    (this.geometry = null),
                    (this.extraGeometry = null),
                    (this.camera = null),
                    (this.shading = null),
                    (this.navigation = null),
                    (this.upVector = null),
                    (this.settings = { animationSteps: 40 });
            }
            Init(e) {
                (this.canvas = e), (this.canvas.id = "viewer");
                let t = { canvas: this.canvas, antialias: !0 };
                (this.renderer = new THREE.WebGLRenderer(t)),
                    window.devicePixelRatio &&
                        this.renderer.setPixelRatio(window.devicePixelRatio),
                    this.renderer.setClearColor("#ffffff", 1),
                    this.renderer.setSize(
                        this.canvas.width,
                        this.canvas.height
                    ),
                    (this.scene = new THREE.Scene()),
                    (this.geometry = new xr(this.scene)),
                    (this.extraGeometry = new gr(this.scene)),
                    this.InitNavigation(),
                    this.InitShading(),
                    this.Render();
            }
            SetMouseClickHandler(e) {
                this.navigation.SetMouseClickHandler(e);
            }
            SetMouseMoveHandler(e) {
                this.navigation.SetMouseMoveHandler(e);
            }
            SetContextMenuHandler(e) {
                this.navigation.SetContextMenuHandler(e);
            }
            SetEnvironmentMapSettings(e, t) {
                this.shading.SetEnvironment(e, t, () => {
                    this.Render();
                }),
                    this.shading.UpdateShading(),
                    this.Render();
            }
            SetBackgroundColor(e) {
                let t = "#" + ze(e);
                this.renderer.setClearColor(t, 1), this.Render();
            }
            SetEdgeSettings(e, t, r) {
                this.geometry.SetEdgeSettings(e, t, r), this.Render();
            }
            GetCanvas() {
                return this.canvas;
            }
            GetCamera() {
                return this.navigation.GetCamera();
            }
            SetCamera(e) {
                this.navigation.SetCamera(e), this.Render();
            }
            Resize(e, t) {
                let r = Si(this.canvas, e, t);
                this.ResizeRenderer(r.width, r.height);
            }
            ResizeRenderer(e, t) {
                window.devicePixelRatio &&
                    this.renderer.setPixelRatio(window.devicePixelRatio),
                    (this.camera.aspect = e / t),
                    this.camera.updateProjectionMatrix(),
                    this.renderer.setSize(e, t),
                    this.Render();
            }
            FitSphereToWindow(e, t) {
                if (e === null) return;
                let r = new y(e.center.x, e.center.y, e.center.z),
                    i = e.radius,
                    n = this.camera.fov,
                    o = this.navigation.GetFitToSphereCamera(r, i, n);
                this.navigation.MoveCamera(
                    o,
                    t ? this.settings.animationSteps : 0
                );
            }
            AdjustClippingPlanesToSphere(e) {
                e !== null &&
                    (e.radius < 10
                        ? ((this.camera.near = 0.01), (this.camera.far = 100))
                        : e.radius < 100
                        ? ((this.camera.near = 0.1), (this.camera.far = 1e3))
                        : e.radius < 1e3
                        ? ((this.camera.near = 10), (this.camera.far = 1e4))
                        : ((this.camera.near = 100), (this.camera.far = 1e6)),
                    this.camera.updateProjectionMatrix(),
                    this.Render());
            }
            IsFixUpVector() {
                return this.navigation.IsFixUpVector();
            }
            SetFixUpVector(e) {
                let t = this.navigation.GetCamera(),
                    r = this.upVector.SetFixed(e, t);
                this.navigation.SetFixUpVector(e),
                    r !== null &&
                        this.navigation.MoveCamera(
                            r,
                            this.settings.animationSteps
                        ),
                    this.Render();
            }
            SetUpVector(e, t) {
                let r = this.navigation.GetCamera(),
                    i = this.upVector.SetDirection(e, r),
                    n = t ? this.settings.animationSteps : 0;
                this.navigation.MoveCamera(i, n), this.Render();
            }
            FlipUpVector() {
                let e = this.navigation.GetCamera(),
                    t = this.upVector.Flip(e);
                this.navigation.MoveCamera(t, 0), this.Render();
            }
            Render() {
                let e = this.navigation.GetCamera();
                this.camera.position.set(e.eye.x, e.eye.y, e.eye.z),
                    this.camera.up.set(e.up.x, e.up.y, e.up.z),
                    this.camera.lookAt(
                        new THREE.Vector3(e.center.x, e.center.y, e.center.z)
                    ),
                    this.shading.UpdateByCamera(e),
                    this.renderer.render(this.scene, this.camera);
            }
            SetMainObject(e) {
                let t = Ki(e);
                this.geometry.SetMainObject(e),
                    this.shading.SetType(t),
                    this.Render();
            }
            AddExtraObject(e) {
                this.extraGeometry.AddObject(e), this.Render();
            }
            Clear() {
                this.geometry.Clear(),
                    this.extraGeometry.Clear(),
                    this.Render();
            }
            ClearExtra() {
                this.extraGeometry.Clear(), this.Render();
            }
            SetMeshesVisibility(e) {
                this.geometry.EnumerateMeshes((t) => {
                    let r = e(t.userData);
                    t.visible !== r && (t.visible = r);
                }),
                    this.geometry.EnumerateEdges((t) => {
                        let r = e(t.userData);
                        t.visible !== r && (t.visible = r);
                    }),
                    this.Render();
            }
            SetMeshesHighlight(e, t) {
                function r(n, o) {
                    let l = [];
                    for (let a = 0; a < n.length; a++) l.push(o);
                    return l;
                }
                let i = this.CreateHighlightMaterial(e);
                this.geometry.EnumerateMeshes((n) => {
                    t(n.userData)
                        ? n.userData.threeMaterials === null &&
                          ((n.userData.threeMaterials = n.material),
                          (n.material = r(n.material, i)))
                        : n.userData.threeMaterials !== null &&
                          ((n.material = n.userData.threeMaterials),
                          (n.userData.threeMaterials = null));
                }),
                    this.Render();
            }
            CreateHighlightMaterial(e) {
                let t = this.geometry.edgeSettings.showEdges;
                return this.shading.CreateHighlightMaterial(e, t);
            }
            GetMeshUserDataUnderMouse(e) {
                let t = this.GetMeshIntersectionUnderMouse(e);
                return t === null ? null : t.object.userData;
            }
            GetMeshIntersectionUnderMouse(e) {
                let t = this.GetCanvasSize(),
                    r = this.geometry.GetMeshIntersectionUnderMouse(
                        e,
                        this.camera,
                        t.width,
                        t.height
                    );
                return r === null ? null : r;
            }
            GetBoundingBox(e) {
                return this.geometry.GetBoundingBox(e);
            }
            GetBoundingSphere(e) {
                return this.geometry.GetBoundingSphere(e);
            }
            EnumerateMeshesUserData(e) {
                this.geometry.EnumerateMeshes((t) => {
                    e(t.userData);
                });
            }
            InitNavigation() {
                (this.camera = new THREE.PerspectiveCamera(
                    45,
                    this.canvas.width / this.canvas.height,
                    0.1,
                    1e3
                )),
                    this.scene.add(this.camera);
                let e = this.renderer.domElement,
                    t = Gi(w.Z);
                (this.navigation = new pr(e, t, {
                    onUpdate: () => {
                        this.Render();
                    },
                })),
                    (this.upVector = new Hr());
            }
            InitShading() {
                this.shading = new kr(this.scene);
            }
            GetShadingType() {
                return this.shading.type;
            }
            GetImageSize() {
                let e = new THREE.Vector2();
                return (
                    this.renderer.getSize(e),
                    { width: parseInt(e.x, 10), height: parseInt(e.y, 10) }
                );
            }
            GetCanvasSize() {
                let e = this.canvas.width,
                    t = this.canvas.height;
                return (
                    window.devicePixelRatio &&
                        ((e /= window.devicePixelRatio),
                        (t /= window.devicePixelRatio)),
                    { width: e, height: t }
                );
            }
            GetImageAsDataUrl(e, t) {
                let r = this.GetImageSize(),
                    i = e,
                    n = t;
                window.devicePixelRatio &&
                    ((i /= window.devicePixelRatio),
                    (n /= window.devicePixelRatio)),
                    this.ResizeRenderer(i, n),
                    this.Render();
                let o = this.renderer.domElement.toDataURL();
                return this.ResizeRenderer(r.width, r.height), o;
            }
        };
    var Q = {
            IntegerToString(s) {
                return s.toString();
            },
            StringToInteger(s) {
                return parseInt(s, 10);
            },
            NumberToString(s) {
                let e = 5;
                return s.toFixed(e);
            },
            StringToNumber(s) {
                return parseFloat(s);
            },
            ModelUrlsToString: function (s) {
                return s === null ? null : s.join(",");
            },
            StringToModelUrls: function (s) {
                return s === null || s.length === 0 ? null : s.split(",");
            },
            CameraToString: function (s) {
                return s === null
                    ? null
                    : [
                          this.NumberToString(s.eye.x),
                          this.NumberToString(s.eye.y),
                          this.NumberToString(s.eye.z),
                          this.NumberToString(s.center.x),
                          this.NumberToString(s.center.y),
                          this.NumberToString(s.center.z),
                          this.NumberToString(s.up.x),
                          this.NumberToString(s.up.y),
                          this.NumberToString(s.up.z),
                      ].join(",");
            },
            StringToCamera: function (s) {
                if (s === null || s.length === 0) return null;
                let e = s.split(",");
                return e.length !== 9
                    ? null
                    : new Ae(
                          new y(
                              this.StringToNumber(e[0]),
                              this.StringToNumber(e[1]),
                              this.StringToNumber(e[2])
                          ),
                          new y(
                              this.StringToNumber(e[3]),
                              this.StringToNumber(e[4]),
                              this.StringToNumber(e[5])
                          ),
                          new y(
                              this.StringToNumber(e[6]),
                              this.StringToNumber(e[7]),
                              this.StringToNumber(e[8])
                          )
                      );
            },
            ColorToString: function (s) {
                return s === null
                    ? null
                    : [
                          this.IntegerToString(s.r),
                          this.IntegerToString(s.g),
                          this.IntegerToString(s.b),
                      ].join(",");
            },
            StringToColor: function (s) {
                if (s === null || s.length === 0) return null;
                let e = s.split(",");
                return e.length !== 3
                    ? null
                    : new R(
                          this.StringToInteger(e[0]),
                          this.StringToInteger(e[1]),
                          this.StringToInteger(e[2])
                      );
            },
            EnvironmentSettingsToString(s) {
                return s === null
                    ? null
                    : [
                          s.environmentMapName,
                          s.backgroundIsEnvMap ? "on" : "off",
                      ].join(",");
            },
            StringToEnvironmentSettings: function (s) {
                if (s === null || s.length === 0) return null;
                let e = s.split(",");
                return e.length !== 2
                    ? null
                    : {
                          environmentMapName: e[0],
                          backgroundIsEnvMap: e[1] === "on",
                      };
            },
            EdgeSettingsToString: function (s) {
                return s === null
                    ? null
                    : [
                          s.showEdges ? "on" : "off",
                          this.ColorToString(s.edgeColor),
                          this.IntegerToString(s.edgeThreshold),
                      ].join(",");
            },
            StringToEdgeSettings: function (s) {
                if (s === null || s.length === 0) return null;
                let e = s.split(",");
                return e.length !== 5
                    ? null
                    : {
                          showEdges: e[0] === "on",
                          edgeColor: new R(
                              this.StringToInteger(e[1]),
                              this.StringToInteger(e[2]),
                              this.StringToInteger(e[3])
                          ),
                          edgeThreshold: this.StringToInteger(e[4]),
                      };
            },
        },
        jr = class {
            constructor(e) {
                (this.separator = e), (this.paramList = "");
            }
            AddModelUrls(e) {
                return this.AddUrlPart("model", Q.ModelUrlsToString(e)), this;
            }
            AddCamera(e) {
                return this.AddUrlPart("camera", Q.CameraToString(e)), this;
            }
            AddEnvironmentSettings(e) {
                return (
                    this.AddUrlPart(
                        "envsettings",
                        Q.EnvironmentSettingsToString(e)
                    ),
                    this
                );
            }
            AddBackgroundColor(e) {
                return (
                    this.AddUrlPart("backgroundcolor", Q.ColorToString(e)), this
                );
            }
            AddDefaultColor(e) {
                return (
                    this.AddUrlPart("defaultcolor", Q.ColorToString(e)), this
                );
            }
            AddEdgeSettings(e) {
                return (
                    this.AddUrlPart("edgesettings", Q.EdgeSettingsToString(e)),
                    this
                );
            }
            AddUrlPart(e, t) {
                e === null ||
                    t === null ||
                    (this.paramList.length > 0 &&
                        (this.paramList += this.separator),
                    (this.paramList += e + "=" + t));
            }
            GetParameterList() {
                return this.paramList;
            }
        },
        Wr = class {
            constructor(e, t) {
                (this.separator = t), (this.paramList = e);
            }
            GetModelUrls() {
                if (this.paramList.indexOf("=") === -1)
                    return this.paramList.split(",");
                let e = this.GetKeywordParams("model");
                return Q.StringToModelUrls(e);
            }
            GetCamera() {
                let e = this.GetKeywordParams("camera");
                return Q.StringToCamera(e);
            }
            GetEnvironmentSettings() {
                let e = this.GetKeywordParams("envsettings");
                return Q.StringToEnvironmentSettings(e);
            }
            GetBackgroundColor() {
                let e = this.GetKeywordParams("backgroundcolor");
                return Q.StringToColor(e);
            }
            GetDefaultColor() {
                let e = this.GetKeywordParams("defaultcolor");
                return Q.StringToColor(e);
            }
            GetEdgeSettings() {
                let e = this.GetKeywordParams("edgesettings");
                return Q.StringToEdgeSettings(e);
            }
            GetKeywordParams(e) {
                if (this.paramList === null || this.paramList.length === 0)
                    return null;
                let t = e + "=",
                    r = this.paramList.split(this.separator);
                for (let i = 0; i < r.length; i++) {
                    let n = r[i];
                    if (n.startsWith(t)) return n.substring(t.length);
                }
                return null;
            }
        };
    function Zi() {
        return new jr("$");
    }
    function On(s) {
        return new Wr(s, "$");
    }
    function Ln(s) {
        let e = Zi();
        return e.AddModelUrls(s), e.GetParameterList();
    }
    var qr = class {
        constructor(e, t) {
            (this.parentElement = e),
                (this.parameters = {}),
                Gt(t) && (this.parameters = t),
                (this.canvas = document.createElement("canvas")),
                this.parentElement.appendChild(this.canvas),
                (this.viewer = new Cr()),
                this.viewer.Init(this.canvas);
            let r = this.parentElement.clientWidth,
                i = this.parentElement.clientHeight;
            if (
                (this.viewer.Resize(r, i),
                this.parameters.backgroundColor &&
                    this.viewer.SetBackgroundColor(
                        this.parameters.backgroundColor
                    ),
                this.parameters.edgeSettings &&
                    this.viewer.SetEdgeSettings(
                        this.parameters.edgeSettings.showEdges,
                        this.parameters.edgeSettings.edgeColor,
                        this.parameters.edgeSettings.edgeThreshold
                    ),
                this.parameters.environmentSettings)
            ) {
                let n = this.parameters.environmentSettings.environmentMap,
                    o = this.parameters.environmentSettings.backgroundIsEnvMap;
                this.viewer.SetEnvironmentMapSettings(n, o);
            }
            (this.model = null),
                window.addEventListener("resize", () => {
                    this.Resize();
                });
        }
        LoadModelFromUrls(e) {
            ui(e), this.LoadModelInternal(e, $.Url);
        }
        LoadModelFromFileList(e) {
            this.LoadModelInternal(e, $.File);
        }
        LoadModelInternal(e, t) {
            if (e === null || e.length === 0) return null;
            this.viewer.Clear();
            let r = new tr();
            this.parameters.defaultColor &&
                (r.defaultColor = this.parameters.defaultColor),
                (this.model = null);
            let i = null;
            new mr().LoadModel(e, t, r, {
                onLoadStart: () => {
                    (this.canvas.style.display = "none"),
                        (i = document.createElement("div")),
                        (i.innerHTML = "Loading model..."),
                        this.parentElement.appendChild(i);
                },
                onImportStart: () => {
                    i.innerHTML = "Importing model...";
                },
                onVisualizationStart: () => {
                    i.innerHTML = "Visualizing model...";
                },
                onModelFinished: (o, l) => {
                    this.parentElement.removeChild(i),
                        (this.canvas.style.display = "inherit"),
                        this.viewer.SetMainObject(l);
                    let a = this.viewer.GetBoundingSphere((u) => !0);
                    this.viewer.AdjustClippingPlanesToSphere(a),
                        this.parameters.camera
                            ? this.viewer.SetCamera(this.parameters.camera)
                            : this.viewer.SetUpVector(w.Y, !1),
                        this.viewer.FitSphereToWindow(a, !1),
                        (this.model = o.model),
                        this.parameters.onModelLoaded &&
                            this.parameters.onModelLoaded();
                },
                onTextureLoaded: () => {
                    this.viewer.Render();
                },
                onLoadError: (o) => {
                    let l = "Unknown error";
                    o.code === We.NoImportableFile
                        ? (l = "No importable file found")
                        : o.code === We.FailedToLoadFile
                        ? (l = "Failed to load file for import.")
                        : o.code === We.ImportFailed &&
                          (l = "Failed to import model."),
                        o.message !== null && (l += " (" + o.message + ")"),
                        (i.innerHTML = l);
                },
            });
        }
        GetViewer() {
            return this.viewer;
        }
        GetModel() {
            return this.model;
        }
        Resize() {
            let e = this.parentElement.clientWidth,
                t = this.parentElement.clientHeight;
            this.viewer.Resize(e, t);
        }
    };
    function Qi(s, e, t) {
        let r = new qr(s, t);
        return r.LoadModelFromUrls(e), r;
    }
    function Bn(s) {
        function e(r) {
            let i = null,
                n = r.getAttribute("camera");
            n && (i = Q.StringToCamera(n));
            let o = null,
                l = r.getAttribute("backgroundcolor");
            l && (o = Q.StringToColor(l));
            let a = null,
                u = r.getAttribute("defaultcolor");
            u && (a = Q.StringToColor(u));
            let h = null,
                f = r.getAttribute("edgesettings");
            f && (h = Q.StringToEdgeSettings(f));
            let d = null,
                c = r.getAttribute("environmentmap");
            if (c) {
                let x = c.split(",");
                if (x.length === 6) {
                    let g = !1,
                        C = r.getAttribute("environmentmapbg");
                    C && C === "true" && (g = !0),
                        (d = { environmentMap: x, backgroundIsEnvMap: g });
                }
            }
            let p = null,
                m = r.getAttribute("model");
            return (
                m && (p = Q.StringToModelUrls(m)),
                Qi(r, p, {
                    camera: i,
                    backgroundColor: o,
                    defaultColor: a,
                    edgeSettings: h,
                    environmentSettings: d,
                })
            );
        }
        let t = [];
        window.addEventListener("load", () => {
            let r = document.getElementsByClassName("online_3d_viewer");
            for (let i = 0; i < r.length; i++) {
                let n = r[i],
                    o = e(n);
                t.push(o);
            }
            s?.(t);
        });
    }
    return jn(Xn);
})();
